/* 
 * kpack
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0.1.3
 * 
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using RestSharp;
using Org.OpenAPITools.Client;
using Org.OpenAPITools.Model;

namespace Org.OpenAPITools.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IKpackApi : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Creates a namespace scoped Build
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="body">The JSON schema of the Resource to create.</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>KpackBuildV1alpha1Build</returns>
        KpackBuildV1alpha1Build CreateBuild (string _namespace, KpackBuildV1alpha1Build body, string pretty = default(string));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Creates a namespace scoped Build
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="body">The JSON schema of the Resource to create.</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1Build</returns>
        ApiResponse<KpackBuildV1alpha1Build> CreateBuildWithHttpInfo (string _namespace, KpackBuildV1alpha1Build body, string pretty = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Creates a namespace scoped Builder
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="body">The JSON schema of the Resource to create.</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>KpackBuildV1alpha1Builder</returns>
        KpackBuildV1alpha1Builder CreateBuilder (string _namespace, KpackBuildV1alpha1Builder body, string pretty = default(string));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Creates a namespace scoped Builder
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="body">The JSON schema of the Resource to create.</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1Builder</returns>
        ApiResponse<KpackBuildV1alpha1Builder> CreateBuilderWithHttpInfo (string _namespace, KpackBuildV1alpha1Builder body, string pretty = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Creates a cluster scoped ClusterBuilder
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The JSON schema of the Resource to create.</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>KpackBuildV1alpha1ClusterBuilder</returns>
        KpackBuildV1alpha1ClusterBuilder CreateClusterBuilder (KpackBuildV1alpha1ClusterBuilder body, string pretty = default(string));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Creates a cluster scoped ClusterBuilder
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The JSON schema of the Resource to create.</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1ClusterBuilder</returns>
        ApiResponse<KpackBuildV1alpha1ClusterBuilder> CreateClusterBuilderWithHttpInfo (KpackBuildV1alpha1ClusterBuilder body, string pretty = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Creates a cluster scoped ClusterStack
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The JSON schema of the Resource to create.</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>KpackBuildV1alpha1ClusterStack</returns>
        KpackBuildV1alpha1ClusterStack CreateClusterStack (KpackBuildV1alpha1ClusterStack body, string pretty = default(string));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Creates a cluster scoped ClusterStack
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The JSON schema of the Resource to create.</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1ClusterStack</returns>
        ApiResponse<KpackBuildV1alpha1ClusterStack> CreateClusterStackWithHttpInfo (KpackBuildV1alpha1ClusterStack body, string pretty = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Creates a cluster scoped ClusterStore
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The JSON schema of the Resource to create.</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>KpackBuildV1alpha1ClusterStore</returns>
        KpackBuildV1alpha1ClusterStore CreateClusterStore (KpackBuildV1alpha1ClusterStore body, string pretty = default(string));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Creates a cluster scoped ClusterStore
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The JSON schema of the Resource to create.</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1ClusterStore</returns>
        ApiResponse<KpackBuildV1alpha1ClusterStore> CreateClusterStoreWithHttpInfo (KpackBuildV1alpha1ClusterStore body, string pretty = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Creates a namespace scoped Image
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="body">The JSON schema of the Resource to create.</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>KpackBuildV1alpha1Image</returns>
        KpackBuildV1alpha1Image CreateImage (string _namespace, KpackBuildV1alpha1Image body, string pretty = default(string));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Creates a namespace scoped Image
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="body">The JSON schema of the Resource to create.</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1Image</returns>
        ApiResponse<KpackBuildV1alpha1Image> CreateImageWithHttpInfo (string _namespace, KpackBuildV1alpha1Image body, string pretty = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Creates a namespace scoped SourceResolver
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="body">The JSON schema of the Resource to create.</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>KpackBuildV1alpha1SourceResolver</returns>
        KpackBuildV1alpha1SourceResolver CreateSourceResolver (string _namespace, KpackBuildV1alpha1SourceResolver body, string pretty = default(string));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Creates a namespace scoped SourceResolver
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="body">The JSON schema of the Resource to create.</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1SourceResolver</returns>
        ApiResponse<KpackBuildV1alpha1SourceResolver> CreateSourceResolverWithHttpInfo (string _namespace, KpackBuildV1alpha1SourceResolver body, string pretty = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Deletes the specified namespace scoped Build
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <returns>IoK8sApimachineryPkgApisMetaV1Status</returns>
        IoK8sApimachineryPkgApisMetaV1Status DeleteBuild (string _namespace, string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), IoK8sApimachineryPkgApisMetaV1DeleteOptions body = default(IoK8sApimachineryPkgApisMetaV1DeleteOptions));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Deletes the specified namespace scoped Build
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <returns>ApiResponse of IoK8sApimachineryPkgApisMetaV1Status</returns>
        ApiResponse<IoK8sApimachineryPkgApisMetaV1Status> DeleteBuildWithHttpInfo (string _namespace, string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), IoK8sApimachineryPkgApisMetaV1DeleteOptions body = default(IoK8sApimachineryPkgApisMetaV1DeleteOptions));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Deletes the specified namespace scoped Builder
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <returns>IoK8sApimachineryPkgApisMetaV1Status</returns>
        IoK8sApimachineryPkgApisMetaV1Status DeleteBuilder (string _namespace, string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), IoK8sApimachineryPkgApisMetaV1DeleteOptions body = default(IoK8sApimachineryPkgApisMetaV1DeleteOptions));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Deletes the specified namespace scoped Builder
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <returns>ApiResponse of IoK8sApimachineryPkgApisMetaV1Status</returns>
        ApiResponse<IoK8sApimachineryPkgApisMetaV1Status> DeleteBuilderWithHttpInfo (string _namespace, string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), IoK8sApimachineryPkgApisMetaV1DeleteOptions body = default(IoK8sApimachineryPkgApisMetaV1DeleteOptions));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Deletes the specified cluster scoped ClusterBuilder
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <returns>IoK8sApimachineryPkgApisMetaV1Status</returns>
        IoK8sApimachineryPkgApisMetaV1Status DeleteClusterBuilder (string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), IoK8sApimachineryPkgApisMetaV1DeleteOptions body = default(IoK8sApimachineryPkgApisMetaV1DeleteOptions));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Deletes the specified cluster scoped ClusterBuilder
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <returns>ApiResponse of IoK8sApimachineryPkgApisMetaV1Status</returns>
        ApiResponse<IoK8sApimachineryPkgApisMetaV1Status> DeleteClusterBuilderWithHttpInfo (string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), IoK8sApimachineryPkgApisMetaV1DeleteOptions body = default(IoK8sApimachineryPkgApisMetaV1DeleteOptions));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Deletes the specified cluster scoped ClusterStack
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <returns>IoK8sApimachineryPkgApisMetaV1Status</returns>
        IoK8sApimachineryPkgApisMetaV1Status DeleteClusterStack (string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), IoK8sApimachineryPkgApisMetaV1DeleteOptions body = default(IoK8sApimachineryPkgApisMetaV1DeleteOptions));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Deletes the specified cluster scoped ClusterStack
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <returns>ApiResponse of IoK8sApimachineryPkgApisMetaV1Status</returns>
        ApiResponse<IoK8sApimachineryPkgApisMetaV1Status> DeleteClusterStackWithHttpInfo (string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), IoK8sApimachineryPkgApisMetaV1DeleteOptions body = default(IoK8sApimachineryPkgApisMetaV1DeleteOptions));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Deletes the specified cluster scoped ClusterStore
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <returns>IoK8sApimachineryPkgApisMetaV1Status</returns>
        IoK8sApimachineryPkgApisMetaV1Status DeleteClusterStore (string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), IoK8sApimachineryPkgApisMetaV1DeleteOptions body = default(IoK8sApimachineryPkgApisMetaV1DeleteOptions));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Deletes the specified cluster scoped ClusterStore
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <returns>ApiResponse of IoK8sApimachineryPkgApisMetaV1Status</returns>
        ApiResponse<IoK8sApimachineryPkgApisMetaV1Status> DeleteClusterStoreWithHttpInfo (string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), IoK8sApimachineryPkgApisMetaV1DeleteOptions body = default(IoK8sApimachineryPkgApisMetaV1DeleteOptions));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Deletes the specified namespace scoped Image
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <returns>IoK8sApimachineryPkgApisMetaV1Status</returns>
        IoK8sApimachineryPkgApisMetaV1Status DeleteImage (string _namespace, string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), IoK8sApimachineryPkgApisMetaV1DeleteOptions body = default(IoK8sApimachineryPkgApisMetaV1DeleteOptions));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Deletes the specified namespace scoped Image
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <returns>ApiResponse of IoK8sApimachineryPkgApisMetaV1Status</returns>
        ApiResponse<IoK8sApimachineryPkgApisMetaV1Status> DeleteImageWithHttpInfo (string _namespace, string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), IoK8sApimachineryPkgApisMetaV1DeleteOptions body = default(IoK8sApimachineryPkgApisMetaV1DeleteOptions));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Deletes the specified namespace scoped SourceResolver
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <returns>IoK8sApimachineryPkgApisMetaV1Status</returns>
        IoK8sApimachineryPkgApisMetaV1Status DeleteSourceResolver (string _namespace, string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), IoK8sApimachineryPkgApisMetaV1DeleteOptions body = default(IoK8sApimachineryPkgApisMetaV1DeleteOptions));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Deletes the specified namespace scoped SourceResolver
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <returns>ApiResponse of IoK8sApimachineryPkgApisMetaV1Status</returns>
        ApiResponse<IoK8sApimachineryPkgApisMetaV1Status> DeleteSourceResolverWithHttpInfo (string _namespace, string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), IoK8sApimachineryPkgApisMetaV1DeleteOptions body = default(IoK8sApimachineryPkgApisMetaV1DeleteOptions));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Returns a namespace scoped custom object
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>KpackBuildV1alpha1Build</returns>
        KpackBuildV1alpha1Build GetBuild (string _namespace, string name);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Returns a namespace scoped custom object
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1Build</returns>
        ApiResponse<KpackBuildV1alpha1Build> GetBuildWithHttpInfo (string _namespace, string name);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read status of the specified namespace scoped Build
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>KpackBuildV1alpha1Build</returns>
        KpackBuildV1alpha1Build GetBuildStatus (string _namespace, string name);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read status of the specified namespace scoped Build
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1Build</returns>
        ApiResponse<KpackBuildV1alpha1Build> GetBuildStatusWithHttpInfo (string _namespace, string name);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Returns a namespace scoped custom object
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>KpackBuildV1alpha1Builder</returns>
        KpackBuildV1alpha1Builder GetBuilder (string _namespace, string name);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Returns a namespace scoped custom object
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1Builder</returns>
        ApiResponse<KpackBuildV1alpha1Builder> GetBuilderWithHttpInfo (string _namespace, string name);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read status of the specified namespace scoped Builder
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>KpackBuildV1alpha1Builder</returns>
        KpackBuildV1alpha1Builder GetBuilderStatus (string _namespace, string name);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read status of the specified namespace scoped Builder
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1Builder</returns>
        ApiResponse<KpackBuildV1alpha1Builder> GetBuilderStatusWithHttpInfo (string _namespace, string name);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Returns a cluster scoped ClusterBuilder
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>KpackBuildV1alpha1ClusterBuilder</returns>
        KpackBuildV1alpha1ClusterBuilder GetClusterBuilder (string name);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Returns a cluster scoped ClusterBuilder
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1ClusterBuilder</returns>
        ApiResponse<KpackBuildV1alpha1ClusterBuilder> GetClusterBuilderWithHttpInfo (string name);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read status of the specified cluster scoped ClusterBuilder
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>KpackBuildV1alpha1ClusterBuilder</returns>
        KpackBuildV1alpha1ClusterBuilder GetClusterBuilderStatus (string name);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read status of the specified cluster scoped ClusterBuilder
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1ClusterBuilder</returns>
        ApiResponse<KpackBuildV1alpha1ClusterBuilder> GetClusterBuilderStatusWithHttpInfo (string name);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Returns a cluster scoped ClusterStack
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>KpackBuildV1alpha1ClusterStack</returns>
        KpackBuildV1alpha1ClusterStack GetClusterStack (string name);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Returns a cluster scoped ClusterStack
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1ClusterStack</returns>
        ApiResponse<KpackBuildV1alpha1ClusterStack> GetClusterStackWithHttpInfo (string name);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read status of the specified cluster scoped ClusterStack
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>KpackBuildV1alpha1ClusterStack</returns>
        KpackBuildV1alpha1ClusterStack GetClusterStackStatus (string name);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read status of the specified cluster scoped ClusterStack
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1ClusterStack</returns>
        ApiResponse<KpackBuildV1alpha1ClusterStack> GetClusterStackStatusWithHttpInfo (string name);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Returns a cluster scoped ClusterStore
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>KpackBuildV1alpha1ClusterStore</returns>
        KpackBuildV1alpha1ClusterStore GetClusterStore (string name);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Returns a cluster scoped ClusterStore
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1ClusterStore</returns>
        ApiResponse<KpackBuildV1alpha1ClusterStore> GetClusterStoreWithHttpInfo (string name);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read status of the specified cluster scoped ClusterStore
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>KpackBuildV1alpha1ClusterStore</returns>
        KpackBuildV1alpha1ClusterStore GetClusterStoreStatus (string name);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read status of the specified cluster scoped ClusterStore
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1ClusterStore</returns>
        ApiResponse<KpackBuildV1alpha1ClusterStore> GetClusterStoreStatusWithHttpInfo (string name);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Returns a namespace scoped custom object
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>KpackBuildV1alpha1Image</returns>
        KpackBuildV1alpha1Image GetImage (string _namespace, string name);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Returns a namespace scoped custom object
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1Image</returns>
        ApiResponse<KpackBuildV1alpha1Image> GetImageWithHttpInfo (string _namespace, string name);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read status of the specified namespace scoped Image
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>KpackBuildV1alpha1Image</returns>
        KpackBuildV1alpha1Image GetImageStatus (string _namespace, string name);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read status of the specified namespace scoped Image
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1Image</returns>
        ApiResponse<KpackBuildV1alpha1Image> GetImageStatusWithHttpInfo (string _namespace, string name);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Returns a namespace scoped custom object
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>KpackBuildV1alpha1SourceResolver</returns>
        KpackBuildV1alpha1SourceResolver GetSourceResolver (string _namespace, string name);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Returns a namespace scoped custom object
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1SourceResolver</returns>
        ApiResponse<KpackBuildV1alpha1SourceResolver> GetSourceResolverWithHttpInfo (string _namespace, string name);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read status of the specified namespace scoped SourceResolver
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>KpackBuildV1alpha1SourceResolver</returns>
        KpackBuildV1alpha1SourceResolver GetSourceResolverStatus (string _namespace, string name);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read status of the specified namespace scoped SourceResolver
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1SourceResolver</returns>
        ApiResponse<KpackBuildV1alpha1SourceResolver> GetSourceResolverStatusWithHttpInfo (string _namespace, string name);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch builders
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>KpackBuildV1alpha1BuilderList</returns>
        KpackBuildV1alpha1BuilderList ListAllBuilders (string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch builders
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1BuilderList</returns>
        ApiResponse<KpackBuildV1alpha1BuilderList> ListAllBuildersWithHttpInfo (string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch builds
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>KpackBuildV1alpha1BuildList</returns>
        KpackBuildV1alpha1BuildList ListAllBuilds (string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch builds
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1BuildList</returns>
        ApiResponse<KpackBuildV1alpha1BuildList> ListAllBuildsWithHttpInfo (string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch cluster scoped clusterbuilders
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>KpackBuildV1alpha1ClusterBuilderList</returns>
        KpackBuildV1alpha1ClusterBuilderList ListAllClusterbuilders (string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch cluster scoped clusterbuilders
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1ClusterBuilderList</returns>
        ApiResponse<KpackBuildV1alpha1ClusterBuilderList> ListAllClusterbuildersWithHttpInfo (string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch cluster scoped clusterstacks
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>KpackBuildV1alpha1ClusterStackList</returns>
        KpackBuildV1alpha1ClusterStackList ListAllClusterstacks (string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch cluster scoped clusterstacks
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1ClusterStackList</returns>
        ApiResponse<KpackBuildV1alpha1ClusterStackList> ListAllClusterstacksWithHttpInfo (string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch cluster scoped clusterstores
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>KpackBuildV1alpha1ClusterStoreList</returns>
        KpackBuildV1alpha1ClusterStoreList ListAllClusterstores (string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch cluster scoped clusterstores
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1ClusterStoreList</returns>
        ApiResponse<KpackBuildV1alpha1ClusterStoreList> ListAllClusterstoresWithHttpInfo (string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch images
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>KpackBuildV1alpha1ImageList</returns>
        KpackBuildV1alpha1ImageList ListAllImages (string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch images
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1ImageList</returns>
        ApiResponse<KpackBuildV1alpha1ImageList> ListAllImagesWithHttpInfo (string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch sourceresolvers
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>KpackBuildV1alpha1SourceResolverList</returns>
        KpackBuildV1alpha1SourceResolverList ListAllSourceresolvers (string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch sourceresolvers
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1SourceResolverList</returns>
        ApiResponse<KpackBuildV1alpha1SourceResolverList> ListAllSourceresolversWithHttpInfo (string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch namespace scoped builders
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>KpackBuildV1alpha1BuilderList</returns>
        KpackBuildV1alpha1BuilderList ListNamespacedBuilders (string _namespace, string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch namespace scoped builders
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1BuilderList</returns>
        ApiResponse<KpackBuildV1alpha1BuilderList> ListNamespacedBuildersWithHttpInfo (string _namespace, string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch namespace scoped builds
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>KpackBuildV1alpha1BuildList</returns>
        KpackBuildV1alpha1BuildList ListNamespacedBuilds (string _namespace, string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch namespace scoped builds
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1BuildList</returns>
        ApiResponse<KpackBuildV1alpha1BuildList> ListNamespacedBuildsWithHttpInfo (string _namespace, string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch namespace scoped images
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>KpackBuildV1alpha1ImageList</returns>
        KpackBuildV1alpha1ImageList ListNamespacedImages (string _namespace, string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch namespace scoped images
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1ImageList</returns>
        ApiResponse<KpackBuildV1alpha1ImageList> ListNamespacedImagesWithHttpInfo (string _namespace, string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch namespace scoped sourceresolvers
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>KpackBuildV1alpha1SourceResolverList</returns>
        KpackBuildV1alpha1SourceResolverList ListNamespacedSourceresolvers (string _namespace, string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch namespace scoped sourceresolvers
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1SourceResolverList</returns>
        ApiResponse<KpackBuildV1alpha1SourceResolverList> ListNamespacedSourceresolversWithHttpInfo (string _namespace, string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// patch the specified namespace scoped Build
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to patch.</param>
        /// <returns>KpackBuildV1alpha1Build</returns>
        KpackBuildV1alpha1Build PatchBuild (string _namespace, string name, Object body);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// patch the specified namespace scoped Build
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to patch.</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1Build</returns>
        ApiResponse<KpackBuildV1alpha1Build> PatchBuildWithHttpInfo (string _namespace, string name, Object body);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update status of the specified namespace scoped Build
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>KpackBuildV1alpha1Build</returns>
        KpackBuildV1alpha1Build PatchBuildStatus (string _namespace, string name, Object body);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update status of the specified namespace scoped Build
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>ApiResponse of KpackBuildV1alpha1Build</returns>
        ApiResponse<KpackBuildV1alpha1Build> PatchBuildStatusWithHttpInfo (string _namespace, string name, Object body);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// patch the specified namespace scoped Builder
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to patch.</param>
        /// <returns>KpackBuildV1alpha1Builder</returns>
        KpackBuildV1alpha1Builder PatchBuilder (string _namespace, string name, Object body);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// patch the specified namespace scoped Builder
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to patch.</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1Builder</returns>
        ApiResponse<KpackBuildV1alpha1Builder> PatchBuilderWithHttpInfo (string _namespace, string name, Object body);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update status of the specified namespace scoped Builder
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>KpackBuildV1alpha1Builder</returns>
        KpackBuildV1alpha1Builder PatchBuilderStatus (string _namespace, string name, Object body);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update status of the specified namespace scoped Builder
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>ApiResponse of KpackBuildV1alpha1Builder</returns>
        ApiResponse<KpackBuildV1alpha1Builder> PatchBuilderStatusWithHttpInfo (string _namespace, string name, Object body);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// patch the specified cluster scoped ClusterBuilder
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to patch.</param>
        /// <returns>KpackBuildV1alpha1ClusterBuilder</returns>
        KpackBuildV1alpha1ClusterBuilder PatchClusterBuilder (string name, Object body);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// patch the specified cluster scoped ClusterBuilder
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to patch.</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1ClusterBuilder</returns>
        ApiResponse<KpackBuildV1alpha1ClusterBuilder> PatchClusterBuilderWithHttpInfo (string name, Object body);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update status of the specified cluster scoped ClusterBuilder
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>KpackBuildV1alpha1ClusterBuilder</returns>
        KpackBuildV1alpha1ClusterBuilder PatchClusterBuilderStatus (string name, Object body);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update status of the specified cluster scoped ClusterBuilder
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>ApiResponse of KpackBuildV1alpha1ClusterBuilder</returns>
        ApiResponse<KpackBuildV1alpha1ClusterBuilder> PatchClusterBuilderStatusWithHttpInfo (string name, Object body);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// patch the specified cluster scoped ClusterStack
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to patch.</param>
        /// <returns>KpackBuildV1alpha1ClusterStack</returns>
        KpackBuildV1alpha1ClusterStack PatchClusterStack (string name, Object body);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// patch the specified cluster scoped ClusterStack
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to patch.</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1ClusterStack</returns>
        ApiResponse<KpackBuildV1alpha1ClusterStack> PatchClusterStackWithHttpInfo (string name, Object body);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update status of the specified cluster scoped ClusterStack
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>KpackBuildV1alpha1ClusterStack</returns>
        KpackBuildV1alpha1ClusterStack PatchClusterStackStatus (string name, Object body);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update status of the specified cluster scoped ClusterStack
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>ApiResponse of KpackBuildV1alpha1ClusterStack</returns>
        ApiResponse<KpackBuildV1alpha1ClusterStack> PatchClusterStackStatusWithHttpInfo (string name, Object body);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// patch the specified cluster scoped ClusterStore
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to patch.</param>
        /// <returns>KpackBuildV1alpha1ClusterStore</returns>
        KpackBuildV1alpha1ClusterStore PatchClusterStore (string name, Object body);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// patch the specified cluster scoped ClusterStore
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to patch.</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1ClusterStore</returns>
        ApiResponse<KpackBuildV1alpha1ClusterStore> PatchClusterStoreWithHttpInfo (string name, Object body);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update status of the specified cluster scoped ClusterStore
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>KpackBuildV1alpha1ClusterStore</returns>
        KpackBuildV1alpha1ClusterStore PatchClusterStoreStatus (string name, Object body);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update status of the specified cluster scoped ClusterStore
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>ApiResponse of KpackBuildV1alpha1ClusterStore</returns>
        ApiResponse<KpackBuildV1alpha1ClusterStore> PatchClusterStoreStatusWithHttpInfo (string name, Object body);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// patch the specified namespace scoped Image
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to patch.</param>
        /// <returns>KpackBuildV1alpha1Image</returns>
        KpackBuildV1alpha1Image PatchImage (string _namespace, string name, Object body);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// patch the specified namespace scoped Image
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to patch.</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1Image</returns>
        ApiResponse<KpackBuildV1alpha1Image> PatchImageWithHttpInfo (string _namespace, string name, Object body);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update status of the specified namespace scoped Image
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>KpackBuildV1alpha1Image</returns>
        KpackBuildV1alpha1Image PatchImageStatus (string _namespace, string name, Object body);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update status of the specified namespace scoped Image
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>ApiResponse of KpackBuildV1alpha1Image</returns>
        ApiResponse<KpackBuildV1alpha1Image> PatchImageStatusWithHttpInfo (string _namespace, string name, Object body);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// patch the specified namespace scoped SourceResolver
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to patch.</param>
        /// <returns>KpackBuildV1alpha1SourceResolver</returns>
        KpackBuildV1alpha1SourceResolver PatchSourceResolver (string _namespace, string name, Object body);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// patch the specified namespace scoped SourceResolver
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to patch.</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1SourceResolver</returns>
        ApiResponse<KpackBuildV1alpha1SourceResolver> PatchSourceResolverWithHttpInfo (string _namespace, string name, Object body);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update status of the specified namespace scoped SourceResolver
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>KpackBuildV1alpha1SourceResolver</returns>
        KpackBuildV1alpha1SourceResolver PatchSourceResolverStatus (string _namespace, string name, Object body);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update status of the specified namespace scoped SourceResolver
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>ApiResponse of KpackBuildV1alpha1SourceResolver</returns>
        ApiResponse<KpackBuildV1alpha1SourceResolver> PatchSourceResolverStatusWithHttpInfo (string _namespace, string name, Object body);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified namespace scoped custom object
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to replace.</param>
        /// <returns>KpackBuildV1alpha1Build</returns>
        KpackBuildV1alpha1Build ReplaceBuild (string _namespace, string name, KpackBuildV1alpha1Build body);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified namespace scoped custom object
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to replace.</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1Build</returns>
        ApiResponse<KpackBuildV1alpha1Build> ReplaceBuildWithHttpInfo (string _namespace, string name, KpackBuildV1alpha1Build body);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace status of the specified namespace scoped Build
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>KpackBuildV1alpha1Build</returns>
        KpackBuildV1alpha1Build ReplaceBuildStatus (string _namespace, string name, KpackBuildV1alpha1Build body);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace status of the specified namespace scoped Build
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>ApiResponse of KpackBuildV1alpha1Build</returns>
        ApiResponse<KpackBuildV1alpha1Build> ReplaceBuildStatusWithHttpInfo (string _namespace, string name, KpackBuildV1alpha1Build body);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified namespace scoped custom object
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to replace.</param>
        /// <returns>KpackBuildV1alpha1Builder</returns>
        KpackBuildV1alpha1Builder ReplaceBuilder (string _namespace, string name, KpackBuildV1alpha1Builder body);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified namespace scoped custom object
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to replace.</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1Builder</returns>
        ApiResponse<KpackBuildV1alpha1Builder> ReplaceBuilderWithHttpInfo (string _namespace, string name, KpackBuildV1alpha1Builder body);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace status of the specified namespace scoped Builder
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>KpackBuildV1alpha1Builder</returns>
        KpackBuildV1alpha1Builder ReplaceBuilderStatus (string _namespace, string name, KpackBuildV1alpha1Builder body);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace status of the specified namespace scoped Builder
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>ApiResponse of KpackBuildV1alpha1Builder</returns>
        ApiResponse<KpackBuildV1alpha1Builder> ReplaceBuilderStatusWithHttpInfo (string _namespace, string name, KpackBuildV1alpha1Builder body);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified cluster scoped ClusterBuilder
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to replace.</param>
        /// <returns>KpackBuildV1alpha1ClusterBuilder</returns>
        KpackBuildV1alpha1ClusterBuilder ReplaceClusterBuilder (string name, KpackBuildV1alpha1ClusterBuilder body);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified cluster scoped ClusterBuilder
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to replace.</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1ClusterBuilder</returns>
        ApiResponse<KpackBuildV1alpha1ClusterBuilder> ReplaceClusterBuilderWithHttpInfo (string name, KpackBuildV1alpha1ClusterBuilder body);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace status of the specified cluster scoped ClusterBuilder
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>KpackBuildV1alpha1ClusterBuilder</returns>
        KpackBuildV1alpha1ClusterBuilder ReplaceClusterBuilderStatus (string name, KpackBuildV1alpha1ClusterBuilder body);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace status of the specified cluster scoped ClusterBuilder
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>ApiResponse of KpackBuildV1alpha1ClusterBuilder</returns>
        ApiResponse<KpackBuildV1alpha1ClusterBuilder> ReplaceClusterBuilderStatusWithHttpInfo (string name, KpackBuildV1alpha1ClusterBuilder body);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified cluster scoped ClusterStack
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to replace.</param>
        /// <returns>KpackBuildV1alpha1ClusterStack</returns>
        KpackBuildV1alpha1ClusterStack ReplaceClusterStack (string name, KpackBuildV1alpha1ClusterStack body);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified cluster scoped ClusterStack
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to replace.</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1ClusterStack</returns>
        ApiResponse<KpackBuildV1alpha1ClusterStack> ReplaceClusterStackWithHttpInfo (string name, KpackBuildV1alpha1ClusterStack body);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace status of the specified cluster scoped ClusterStack
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>KpackBuildV1alpha1ClusterStack</returns>
        KpackBuildV1alpha1ClusterStack ReplaceClusterStackStatus (string name, KpackBuildV1alpha1ClusterStack body);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace status of the specified cluster scoped ClusterStack
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>ApiResponse of KpackBuildV1alpha1ClusterStack</returns>
        ApiResponse<KpackBuildV1alpha1ClusterStack> ReplaceClusterStackStatusWithHttpInfo (string name, KpackBuildV1alpha1ClusterStack body);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified cluster scoped ClusterStore
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to replace.</param>
        /// <returns>KpackBuildV1alpha1ClusterStore</returns>
        KpackBuildV1alpha1ClusterStore ReplaceClusterStore (string name, KpackBuildV1alpha1ClusterStore body);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified cluster scoped ClusterStore
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to replace.</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1ClusterStore</returns>
        ApiResponse<KpackBuildV1alpha1ClusterStore> ReplaceClusterStoreWithHttpInfo (string name, KpackBuildV1alpha1ClusterStore body);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace status of the specified cluster scoped ClusterStore
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>KpackBuildV1alpha1ClusterStore</returns>
        KpackBuildV1alpha1ClusterStore ReplaceClusterStoreStatus (string name, KpackBuildV1alpha1ClusterStore body);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace status of the specified cluster scoped ClusterStore
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>ApiResponse of KpackBuildV1alpha1ClusterStore</returns>
        ApiResponse<KpackBuildV1alpha1ClusterStore> ReplaceClusterStoreStatusWithHttpInfo (string name, KpackBuildV1alpha1ClusterStore body);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified namespace scoped custom object
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to replace.</param>
        /// <returns>KpackBuildV1alpha1Image</returns>
        KpackBuildV1alpha1Image ReplaceImage (string _namespace, string name, KpackBuildV1alpha1Image body);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified namespace scoped custom object
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to replace.</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1Image</returns>
        ApiResponse<KpackBuildV1alpha1Image> ReplaceImageWithHttpInfo (string _namespace, string name, KpackBuildV1alpha1Image body);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace status of the specified namespace scoped Image
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>KpackBuildV1alpha1Image</returns>
        KpackBuildV1alpha1Image ReplaceImageStatus (string _namespace, string name, KpackBuildV1alpha1Image body);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace status of the specified namespace scoped Image
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>ApiResponse of KpackBuildV1alpha1Image</returns>
        ApiResponse<KpackBuildV1alpha1Image> ReplaceImageStatusWithHttpInfo (string _namespace, string name, KpackBuildV1alpha1Image body);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified namespace scoped custom object
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to replace.</param>
        /// <returns>KpackBuildV1alpha1SourceResolver</returns>
        KpackBuildV1alpha1SourceResolver ReplaceSourceResolver (string _namespace, string name, KpackBuildV1alpha1SourceResolver body);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified namespace scoped custom object
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to replace.</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1SourceResolver</returns>
        ApiResponse<KpackBuildV1alpha1SourceResolver> ReplaceSourceResolverWithHttpInfo (string _namespace, string name, KpackBuildV1alpha1SourceResolver body);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace status of the specified namespace scoped SourceResolver
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>KpackBuildV1alpha1SourceResolver</returns>
        KpackBuildV1alpha1SourceResolver ReplaceSourceResolverStatus (string _namespace, string name, KpackBuildV1alpha1SourceResolver body);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace status of the specified namespace scoped SourceResolver
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>ApiResponse of KpackBuildV1alpha1SourceResolver</returns>
        ApiResponse<KpackBuildV1alpha1SourceResolver> ReplaceSourceResolverStatusWithHttpInfo (string _namespace, string name, KpackBuildV1alpha1SourceResolver body);
        #endregion Synchronous Operations
        #region Asynchronous Operations
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Creates a namespace scoped Build
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="body">The JSON schema of the Resource to create.</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of KpackBuildV1alpha1Build</returns>
        System.Threading.Tasks.Task<KpackBuildV1alpha1Build> CreateBuildAsync (string _namespace, KpackBuildV1alpha1Build body, string pretty = default(string));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Creates a namespace scoped Build
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="body">The JSON schema of the Resource to create.</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1Build)</returns>
        System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1Build>> CreateBuildAsyncWithHttpInfo (string _namespace, KpackBuildV1alpha1Build body, string pretty = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Creates a namespace scoped Builder
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="body">The JSON schema of the Resource to create.</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of KpackBuildV1alpha1Builder</returns>
        System.Threading.Tasks.Task<KpackBuildV1alpha1Builder> CreateBuilderAsync (string _namespace, KpackBuildV1alpha1Builder body, string pretty = default(string));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Creates a namespace scoped Builder
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="body">The JSON schema of the Resource to create.</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1Builder)</returns>
        System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1Builder>> CreateBuilderAsyncWithHttpInfo (string _namespace, KpackBuildV1alpha1Builder body, string pretty = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Creates a cluster scoped ClusterBuilder
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The JSON schema of the Resource to create.</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of KpackBuildV1alpha1ClusterBuilder</returns>
        System.Threading.Tasks.Task<KpackBuildV1alpha1ClusterBuilder> CreateClusterBuilderAsync (KpackBuildV1alpha1ClusterBuilder body, string pretty = default(string));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Creates a cluster scoped ClusterBuilder
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The JSON schema of the Resource to create.</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1ClusterBuilder)</returns>
        System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1ClusterBuilder>> CreateClusterBuilderAsyncWithHttpInfo (KpackBuildV1alpha1ClusterBuilder body, string pretty = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Creates a cluster scoped ClusterStack
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The JSON schema of the Resource to create.</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of KpackBuildV1alpha1ClusterStack</returns>
        System.Threading.Tasks.Task<KpackBuildV1alpha1ClusterStack> CreateClusterStackAsync (KpackBuildV1alpha1ClusterStack body, string pretty = default(string));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Creates a cluster scoped ClusterStack
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The JSON schema of the Resource to create.</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1ClusterStack)</returns>
        System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1ClusterStack>> CreateClusterStackAsyncWithHttpInfo (KpackBuildV1alpha1ClusterStack body, string pretty = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Creates a cluster scoped ClusterStore
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The JSON schema of the Resource to create.</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of KpackBuildV1alpha1ClusterStore</returns>
        System.Threading.Tasks.Task<KpackBuildV1alpha1ClusterStore> CreateClusterStoreAsync (KpackBuildV1alpha1ClusterStore body, string pretty = default(string));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Creates a cluster scoped ClusterStore
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The JSON schema of the Resource to create.</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1ClusterStore)</returns>
        System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1ClusterStore>> CreateClusterStoreAsyncWithHttpInfo (KpackBuildV1alpha1ClusterStore body, string pretty = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Creates a namespace scoped Image
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="body">The JSON schema of the Resource to create.</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of KpackBuildV1alpha1Image</returns>
        System.Threading.Tasks.Task<KpackBuildV1alpha1Image> CreateImageAsync (string _namespace, KpackBuildV1alpha1Image body, string pretty = default(string));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Creates a namespace scoped Image
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="body">The JSON schema of the Resource to create.</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1Image)</returns>
        System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1Image>> CreateImageAsyncWithHttpInfo (string _namespace, KpackBuildV1alpha1Image body, string pretty = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Creates a namespace scoped SourceResolver
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="body">The JSON schema of the Resource to create.</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of KpackBuildV1alpha1SourceResolver</returns>
        System.Threading.Tasks.Task<KpackBuildV1alpha1SourceResolver> CreateSourceResolverAsync (string _namespace, KpackBuildV1alpha1SourceResolver body, string pretty = default(string));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Creates a namespace scoped SourceResolver
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="body">The JSON schema of the Resource to create.</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1SourceResolver)</returns>
        System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1SourceResolver>> CreateSourceResolverAsyncWithHttpInfo (string _namespace, KpackBuildV1alpha1SourceResolver body, string pretty = default(string));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Deletes the specified namespace scoped Build
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <returns>Task of IoK8sApimachineryPkgApisMetaV1Status</returns>
        System.Threading.Tasks.Task<IoK8sApimachineryPkgApisMetaV1Status> DeleteBuildAsync (string _namespace, string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), IoK8sApimachineryPkgApisMetaV1DeleteOptions body = default(IoK8sApimachineryPkgApisMetaV1DeleteOptions));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Deletes the specified namespace scoped Build
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <returns>Task of ApiResponse (IoK8sApimachineryPkgApisMetaV1Status)</returns>
        System.Threading.Tasks.Task<ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>> DeleteBuildAsyncWithHttpInfo (string _namespace, string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), IoK8sApimachineryPkgApisMetaV1DeleteOptions body = default(IoK8sApimachineryPkgApisMetaV1DeleteOptions));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Deletes the specified namespace scoped Builder
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <returns>Task of IoK8sApimachineryPkgApisMetaV1Status</returns>
        System.Threading.Tasks.Task<IoK8sApimachineryPkgApisMetaV1Status> DeleteBuilderAsync (string _namespace, string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), IoK8sApimachineryPkgApisMetaV1DeleteOptions body = default(IoK8sApimachineryPkgApisMetaV1DeleteOptions));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Deletes the specified namespace scoped Builder
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <returns>Task of ApiResponse (IoK8sApimachineryPkgApisMetaV1Status)</returns>
        System.Threading.Tasks.Task<ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>> DeleteBuilderAsyncWithHttpInfo (string _namespace, string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), IoK8sApimachineryPkgApisMetaV1DeleteOptions body = default(IoK8sApimachineryPkgApisMetaV1DeleteOptions));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Deletes the specified cluster scoped ClusterBuilder
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <returns>Task of IoK8sApimachineryPkgApisMetaV1Status</returns>
        System.Threading.Tasks.Task<IoK8sApimachineryPkgApisMetaV1Status> DeleteClusterBuilderAsync (string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), IoK8sApimachineryPkgApisMetaV1DeleteOptions body = default(IoK8sApimachineryPkgApisMetaV1DeleteOptions));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Deletes the specified cluster scoped ClusterBuilder
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <returns>Task of ApiResponse (IoK8sApimachineryPkgApisMetaV1Status)</returns>
        System.Threading.Tasks.Task<ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>> DeleteClusterBuilderAsyncWithHttpInfo (string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), IoK8sApimachineryPkgApisMetaV1DeleteOptions body = default(IoK8sApimachineryPkgApisMetaV1DeleteOptions));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Deletes the specified cluster scoped ClusterStack
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <returns>Task of IoK8sApimachineryPkgApisMetaV1Status</returns>
        System.Threading.Tasks.Task<IoK8sApimachineryPkgApisMetaV1Status> DeleteClusterStackAsync (string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), IoK8sApimachineryPkgApisMetaV1DeleteOptions body = default(IoK8sApimachineryPkgApisMetaV1DeleteOptions));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Deletes the specified cluster scoped ClusterStack
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <returns>Task of ApiResponse (IoK8sApimachineryPkgApisMetaV1Status)</returns>
        System.Threading.Tasks.Task<ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>> DeleteClusterStackAsyncWithHttpInfo (string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), IoK8sApimachineryPkgApisMetaV1DeleteOptions body = default(IoK8sApimachineryPkgApisMetaV1DeleteOptions));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Deletes the specified cluster scoped ClusterStore
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <returns>Task of IoK8sApimachineryPkgApisMetaV1Status</returns>
        System.Threading.Tasks.Task<IoK8sApimachineryPkgApisMetaV1Status> DeleteClusterStoreAsync (string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), IoK8sApimachineryPkgApisMetaV1DeleteOptions body = default(IoK8sApimachineryPkgApisMetaV1DeleteOptions));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Deletes the specified cluster scoped ClusterStore
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <returns>Task of ApiResponse (IoK8sApimachineryPkgApisMetaV1Status)</returns>
        System.Threading.Tasks.Task<ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>> DeleteClusterStoreAsyncWithHttpInfo (string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), IoK8sApimachineryPkgApisMetaV1DeleteOptions body = default(IoK8sApimachineryPkgApisMetaV1DeleteOptions));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Deletes the specified namespace scoped Image
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <returns>Task of IoK8sApimachineryPkgApisMetaV1Status</returns>
        System.Threading.Tasks.Task<IoK8sApimachineryPkgApisMetaV1Status> DeleteImageAsync (string _namespace, string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), IoK8sApimachineryPkgApisMetaV1DeleteOptions body = default(IoK8sApimachineryPkgApisMetaV1DeleteOptions));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Deletes the specified namespace scoped Image
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <returns>Task of ApiResponse (IoK8sApimachineryPkgApisMetaV1Status)</returns>
        System.Threading.Tasks.Task<ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>> DeleteImageAsyncWithHttpInfo (string _namespace, string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), IoK8sApimachineryPkgApisMetaV1DeleteOptions body = default(IoK8sApimachineryPkgApisMetaV1DeleteOptions));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Deletes the specified namespace scoped SourceResolver
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <returns>Task of IoK8sApimachineryPkgApisMetaV1Status</returns>
        System.Threading.Tasks.Task<IoK8sApimachineryPkgApisMetaV1Status> DeleteSourceResolverAsync (string _namespace, string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), IoK8sApimachineryPkgApisMetaV1DeleteOptions body = default(IoK8sApimachineryPkgApisMetaV1DeleteOptions));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Deletes the specified namespace scoped SourceResolver
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <returns>Task of ApiResponse (IoK8sApimachineryPkgApisMetaV1Status)</returns>
        System.Threading.Tasks.Task<ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>> DeleteSourceResolverAsyncWithHttpInfo (string _namespace, string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), IoK8sApimachineryPkgApisMetaV1DeleteOptions body = default(IoK8sApimachineryPkgApisMetaV1DeleteOptions));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Returns a namespace scoped custom object
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>Task of KpackBuildV1alpha1Build</returns>
        System.Threading.Tasks.Task<KpackBuildV1alpha1Build> GetBuildAsync (string _namespace, string name);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Returns a namespace scoped custom object
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1Build)</returns>
        System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1Build>> GetBuildAsyncWithHttpInfo (string _namespace, string name);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read status of the specified namespace scoped Build
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>Task of KpackBuildV1alpha1Build</returns>
        System.Threading.Tasks.Task<KpackBuildV1alpha1Build> GetBuildStatusAsync (string _namespace, string name);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read status of the specified namespace scoped Build
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1Build)</returns>
        System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1Build>> GetBuildStatusAsyncWithHttpInfo (string _namespace, string name);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Returns a namespace scoped custom object
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>Task of KpackBuildV1alpha1Builder</returns>
        System.Threading.Tasks.Task<KpackBuildV1alpha1Builder> GetBuilderAsync (string _namespace, string name);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Returns a namespace scoped custom object
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1Builder)</returns>
        System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1Builder>> GetBuilderAsyncWithHttpInfo (string _namespace, string name);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read status of the specified namespace scoped Builder
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>Task of KpackBuildV1alpha1Builder</returns>
        System.Threading.Tasks.Task<KpackBuildV1alpha1Builder> GetBuilderStatusAsync (string _namespace, string name);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read status of the specified namespace scoped Builder
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1Builder)</returns>
        System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1Builder>> GetBuilderStatusAsyncWithHttpInfo (string _namespace, string name);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Returns a cluster scoped ClusterBuilder
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>Task of KpackBuildV1alpha1ClusterBuilder</returns>
        System.Threading.Tasks.Task<KpackBuildV1alpha1ClusterBuilder> GetClusterBuilderAsync (string name);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Returns a cluster scoped ClusterBuilder
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1ClusterBuilder)</returns>
        System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1ClusterBuilder>> GetClusterBuilderAsyncWithHttpInfo (string name);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read status of the specified cluster scoped ClusterBuilder
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>Task of KpackBuildV1alpha1ClusterBuilder</returns>
        System.Threading.Tasks.Task<KpackBuildV1alpha1ClusterBuilder> GetClusterBuilderStatusAsync (string name);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read status of the specified cluster scoped ClusterBuilder
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1ClusterBuilder)</returns>
        System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1ClusterBuilder>> GetClusterBuilderStatusAsyncWithHttpInfo (string name);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Returns a cluster scoped ClusterStack
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>Task of KpackBuildV1alpha1ClusterStack</returns>
        System.Threading.Tasks.Task<KpackBuildV1alpha1ClusterStack> GetClusterStackAsync (string name);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Returns a cluster scoped ClusterStack
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1ClusterStack)</returns>
        System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1ClusterStack>> GetClusterStackAsyncWithHttpInfo (string name);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read status of the specified cluster scoped ClusterStack
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>Task of KpackBuildV1alpha1ClusterStack</returns>
        System.Threading.Tasks.Task<KpackBuildV1alpha1ClusterStack> GetClusterStackStatusAsync (string name);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read status of the specified cluster scoped ClusterStack
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1ClusterStack)</returns>
        System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1ClusterStack>> GetClusterStackStatusAsyncWithHttpInfo (string name);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Returns a cluster scoped ClusterStore
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>Task of KpackBuildV1alpha1ClusterStore</returns>
        System.Threading.Tasks.Task<KpackBuildV1alpha1ClusterStore> GetClusterStoreAsync (string name);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Returns a cluster scoped ClusterStore
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1ClusterStore)</returns>
        System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1ClusterStore>> GetClusterStoreAsyncWithHttpInfo (string name);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read status of the specified cluster scoped ClusterStore
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>Task of KpackBuildV1alpha1ClusterStore</returns>
        System.Threading.Tasks.Task<KpackBuildV1alpha1ClusterStore> GetClusterStoreStatusAsync (string name);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read status of the specified cluster scoped ClusterStore
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1ClusterStore)</returns>
        System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1ClusterStore>> GetClusterStoreStatusAsyncWithHttpInfo (string name);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Returns a namespace scoped custom object
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>Task of KpackBuildV1alpha1Image</returns>
        System.Threading.Tasks.Task<KpackBuildV1alpha1Image> GetImageAsync (string _namespace, string name);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Returns a namespace scoped custom object
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1Image)</returns>
        System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1Image>> GetImageAsyncWithHttpInfo (string _namespace, string name);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read status of the specified namespace scoped Image
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>Task of KpackBuildV1alpha1Image</returns>
        System.Threading.Tasks.Task<KpackBuildV1alpha1Image> GetImageStatusAsync (string _namespace, string name);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read status of the specified namespace scoped Image
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1Image)</returns>
        System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1Image>> GetImageStatusAsyncWithHttpInfo (string _namespace, string name);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Returns a namespace scoped custom object
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>Task of KpackBuildV1alpha1SourceResolver</returns>
        System.Threading.Tasks.Task<KpackBuildV1alpha1SourceResolver> GetSourceResolverAsync (string _namespace, string name);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// Returns a namespace scoped custom object
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1SourceResolver)</returns>
        System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1SourceResolver>> GetSourceResolverAsyncWithHttpInfo (string _namespace, string name);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read status of the specified namespace scoped SourceResolver
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>Task of KpackBuildV1alpha1SourceResolver</returns>
        System.Threading.Tasks.Task<KpackBuildV1alpha1SourceResolver> GetSourceResolverStatusAsync (string _namespace, string name);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// read status of the specified namespace scoped SourceResolver
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1SourceResolver)</returns>
        System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1SourceResolver>> GetSourceResolverStatusAsyncWithHttpInfo (string _namespace, string name);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch builders
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>Task of KpackBuildV1alpha1BuilderList</returns>
        System.Threading.Tasks.Task<KpackBuildV1alpha1BuilderList> ListAllBuildersAsync (string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch builders
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1BuilderList)</returns>
        System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1BuilderList>> ListAllBuildersAsyncWithHttpInfo (string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch builds
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>Task of KpackBuildV1alpha1BuildList</returns>
        System.Threading.Tasks.Task<KpackBuildV1alpha1BuildList> ListAllBuildsAsync (string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch builds
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1BuildList)</returns>
        System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1BuildList>> ListAllBuildsAsyncWithHttpInfo (string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch cluster scoped clusterbuilders
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>Task of KpackBuildV1alpha1ClusterBuilderList</returns>
        System.Threading.Tasks.Task<KpackBuildV1alpha1ClusterBuilderList> ListAllClusterbuildersAsync (string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch cluster scoped clusterbuilders
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1ClusterBuilderList)</returns>
        System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1ClusterBuilderList>> ListAllClusterbuildersAsyncWithHttpInfo (string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch cluster scoped clusterstacks
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>Task of KpackBuildV1alpha1ClusterStackList</returns>
        System.Threading.Tasks.Task<KpackBuildV1alpha1ClusterStackList> ListAllClusterstacksAsync (string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch cluster scoped clusterstacks
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1ClusterStackList)</returns>
        System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1ClusterStackList>> ListAllClusterstacksAsyncWithHttpInfo (string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch cluster scoped clusterstores
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>Task of KpackBuildV1alpha1ClusterStoreList</returns>
        System.Threading.Tasks.Task<KpackBuildV1alpha1ClusterStoreList> ListAllClusterstoresAsync (string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch cluster scoped clusterstores
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1ClusterStoreList)</returns>
        System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1ClusterStoreList>> ListAllClusterstoresAsyncWithHttpInfo (string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch images
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>Task of KpackBuildV1alpha1ImageList</returns>
        System.Threading.Tasks.Task<KpackBuildV1alpha1ImageList> ListAllImagesAsync (string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch images
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1ImageList)</returns>
        System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1ImageList>> ListAllImagesAsyncWithHttpInfo (string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch sourceresolvers
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>Task of KpackBuildV1alpha1SourceResolverList</returns>
        System.Threading.Tasks.Task<KpackBuildV1alpha1SourceResolverList> ListAllSourceresolversAsync (string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch sourceresolvers
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1SourceResolverList)</returns>
        System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1SourceResolverList>> ListAllSourceresolversAsyncWithHttpInfo (string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch namespace scoped builders
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>Task of KpackBuildV1alpha1BuilderList</returns>
        System.Threading.Tasks.Task<KpackBuildV1alpha1BuilderList> ListNamespacedBuildersAsync (string _namespace, string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch namespace scoped builders
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1BuilderList)</returns>
        System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1BuilderList>> ListNamespacedBuildersAsyncWithHttpInfo (string _namespace, string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch namespace scoped builds
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>Task of KpackBuildV1alpha1BuildList</returns>
        System.Threading.Tasks.Task<KpackBuildV1alpha1BuildList> ListNamespacedBuildsAsync (string _namespace, string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch namespace scoped builds
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1BuildList)</returns>
        System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1BuildList>> ListNamespacedBuildsAsyncWithHttpInfo (string _namespace, string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch namespace scoped images
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>Task of KpackBuildV1alpha1ImageList</returns>
        System.Threading.Tasks.Task<KpackBuildV1alpha1ImageList> ListNamespacedImagesAsync (string _namespace, string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch namespace scoped images
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1ImageList)</returns>
        System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1ImageList>> ListNamespacedImagesAsyncWithHttpInfo (string _namespace, string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch namespace scoped sourceresolvers
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>Task of KpackBuildV1alpha1SourceResolverList</returns>
        System.Threading.Tasks.Task<KpackBuildV1alpha1SourceResolverList> ListNamespacedSourceresolversAsync (string _namespace, string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?));

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// list or watch namespace scoped sourceresolvers
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1SourceResolverList)</returns>
        System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1SourceResolverList>> ListNamespacedSourceresolversAsyncWithHttpInfo (string _namespace, string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?));
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// patch the specified namespace scoped Build
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to patch.</param>
        /// <returns>Task of KpackBuildV1alpha1Build</returns>
        System.Threading.Tasks.Task<KpackBuildV1alpha1Build> PatchBuildAsync (string _namespace, string name, Object body);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// patch the specified namespace scoped Build
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to patch.</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1Build)</returns>
        System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1Build>> PatchBuildAsyncWithHttpInfo (string _namespace, string name, Object body);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update status of the specified namespace scoped Build
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>Task of KpackBuildV1alpha1Build</returns>
        System.Threading.Tasks.Task<KpackBuildV1alpha1Build> PatchBuildStatusAsync (string _namespace, string name, Object body);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update status of the specified namespace scoped Build
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1Build)</returns>
        System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1Build>> PatchBuildStatusAsyncWithHttpInfo (string _namespace, string name, Object body);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// patch the specified namespace scoped Builder
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to patch.</param>
        /// <returns>Task of KpackBuildV1alpha1Builder</returns>
        System.Threading.Tasks.Task<KpackBuildV1alpha1Builder> PatchBuilderAsync (string _namespace, string name, Object body);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// patch the specified namespace scoped Builder
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to patch.</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1Builder)</returns>
        System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1Builder>> PatchBuilderAsyncWithHttpInfo (string _namespace, string name, Object body);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update status of the specified namespace scoped Builder
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>Task of KpackBuildV1alpha1Builder</returns>
        System.Threading.Tasks.Task<KpackBuildV1alpha1Builder> PatchBuilderStatusAsync (string _namespace, string name, Object body);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update status of the specified namespace scoped Builder
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1Builder)</returns>
        System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1Builder>> PatchBuilderStatusAsyncWithHttpInfo (string _namespace, string name, Object body);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// patch the specified cluster scoped ClusterBuilder
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to patch.</param>
        /// <returns>Task of KpackBuildV1alpha1ClusterBuilder</returns>
        System.Threading.Tasks.Task<KpackBuildV1alpha1ClusterBuilder> PatchClusterBuilderAsync (string name, Object body);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// patch the specified cluster scoped ClusterBuilder
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to patch.</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1ClusterBuilder)</returns>
        System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1ClusterBuilder>> PatchClusterBuilderAsyncWithHttpInfo (string name, Object body);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update status of the specified cluster scoped ClusterBuilder
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>Task of KpackBuildV1alpha1ClusterBuilder</returns>
        System.Threading.Tasks.Task<KpackBuildV1alpha1ClusterBuilder> PatchClusterBuilderStatusAsync (string name, Object body);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update status of the specified cluster scoped ClusterBuilder
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1ClusterBuilder)</returns>
        System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1ClusterBuilder>> PatchClusterBuilderStatusAsyncWithHttpInfo (string name, Object body);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// patch the specified cluster scoped ClusterStack
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to patch.</param>
        /// <returns>Task of KpackBuildV1alpha1ClusterStack</returns>
        System.Threading.Tasks.Task<KpackBuildV1alpha1ClusterStack> PatchClusterStackAsync (string name, Object body);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// patch the specified cluster scoped ClusterStack
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to patch.</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1ClusterStack)</returns>
        System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1ClusterStack>> PatchClusterStackAsyncWithHttpInfo (string name, Object body);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update status of the specified cluster scoped ClusterStack
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>Task of KpackBuildV1alpha1ClusterStack</returns>
        System.Threading.Tasks.Task<KpackBuildV1alpha1ClusterStack> PatchClusterStackStatusAsync (string name, Object body);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update status of the specified cluster scoped ClusterStack
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1ClusterStack)</returns>
        System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1ClusterStack>> PatchClusterStackStatusAsyncWithHttpInfo (string name, Object body);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// patch the specified cluster scoped ClusterStore
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to patch.</param>
        /// <returns>Task of KpackBuildV1alpha1ClusterStore</returns>
        System.Threading.Tasks.Task<KpackBuildV1alpha1ClusterStore> PatchClusterStoreAsync (string name, Object body);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// patch the specified cluster scoped ClusterStore
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to patch.</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1ClusterStore)</returns>
        System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1ClusterStore>> PatchClusterStoreAsyncWithHttpInfo (string name, Object body);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update status of the specified cluster scoped ClusterStore
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>Task of KpackBuildV1alpha1ClusterStore</returns>
        System.Threading.Tasks.Task<KpackBuildV1alpha1ClusterStore> PatchClusterStoreStatusAsync (string name, Object body);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update status of the specified cluster scoped ClusterStore
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1ClusterStore)</returns>
        System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1ClusterStore>> PatchClusterStoreStatusAsyncWithHttpInfo (string name, Object body);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// patch the specified namespace scoped Image
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to patch.</param>
        /// <returns>Task of KpackBuildV1alpha1Image</returns>
        System.Threading.Tasks.Task<KpackBuildV1alpha1Image> PatchImageAsync (string _namespace, string name, Object body);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// patch the specified namespace scoped Image
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to patch.</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1Image)</returns>
        System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1Image>> PatchImageAsyncWithHttpInfo (string _namespace, string name, Object body);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update status of the specified namespace scoped Image
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>Task of KpackBuildV1alpha1Image</returns>
        System.Threading.Tasks.Task<KpackBuildV1alpha1Image> PatchImageStatusAsync (string _namespace, string name, Object body);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update status of the specified namespace scoped Image
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1Image)</returns>
        System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1Image>> PatchImageStatusAsyncWithHttpInfo (string _namespace, string name, Object body);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// patch the specified namespace scoped SourceResolver
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to patch.</param>
        /// <returns>Task of KpackBuildV1alpha1SourceResolver</returns>
        System.Threading.Tasks.Task<KpackBuildV1alpha1SourceResolver> PatchSourceResolverAsync (string _namespace, string name, Object body);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// patch the specified namespace scoped SourceResolver
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to patch.</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1SourceResolver)</returns>
        System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1SourceResolver>> PatchSourceResolverAsyncWithHttpInfo (string _namespace, string name, Object body);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update status of the specified namespace scoped SourceResolver
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>Task of KpackBuildV1alpha1SourceResolver</returns>
        System.Threading.Tasks.Task<KpackBuildV1alpha1SourceResolver> PatchSourceResolverStatusAsync (string _namespace, string name, Object body);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// partially update status of the specified namespace scoped SourceResolver
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1SourceResolver)</returns>
        System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1SourceResolver>> PatchSourceResolverStatusAsyncWithHttpInfo (string _namespace, string name, Object body);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified namespace scoped custom object
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to replace.</param>
        /// <returns>Task of KpackBuildV1alpha1Build</returns>
        System.Threading.Tasks.Task<KpackBuildV1alpha1Build> ReplaceBuildAsync (string _namespace, string name, KpackBuildV1alpha1Build body);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified namespace scoped custom object
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to replace.</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1Build)</returns>
        System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1Build>> ReplaceBuildAsyncWithHttpInfo (string _namespace, string name, KpackBuildV1alpha1Build body);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace status of the specified namespace scoped Build
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>Task of KpackBuildV1alpha1Build</returns>
        System.Threading.Tasks.Task<KpackBuildV1alpha1Build> ReplaceBuildStatusAsync (string _namespace, string name, KpackBuildV1alpha1Build body);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace status of the specified namespace scoped Build
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1Build)</returns>
        System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1Build>> ReplaceBuildStatusAsyncWithHttpInfo (string _namespace, string name, KpackBuildV1alpha1Build body);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified namespace scoped custom object
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to replace.</param>
        /// <returns>Task of KpackBuildV1alpha1Builder</returns>
        System.Threading.Tasks.Task<KpackBuildV1alpha1Builder> ReplaceBuilderAsync (string _namespace, string name, KpackBuildV1alpha1Builder body);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified namespace scoped custom object
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to replace.</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1Builder)</returns>
        System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1Builder>> ReplaceBuilderAsyncWithHttpInfo (string _namespace, string name, KpackBuildV1alpha1Builder body);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace status of the specified namespace scoped Builder
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>Task of KpackBuildV1alpha1Builder</returns>
        System.Threading.Tasks.Task<KpackBuildV1alpha1Builder> ReplaceBuilderStatusAsync (string _namespace, string name, KpackBuildV1alpha1Builder body);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace status of the specified namespace scoped Builder
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1Builder)</returns>
        System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1Builder>> ReplaceBuilderStatusAsyncWithHttpInfo (string _namespace, string name, KpackBuildV1alpha1Builder body);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified cluster scoped ClusterBuilder
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to replace.</param>
        /// <returns>Task of KpackBuildV1alpha1ClusterBuilder</returns>
        System.Threading.Tasks.Task<KpackBuildV1alpha1ClusterBuilder> ReplaceClusterBuilderAsync (string name, KpackBuildV1alpha1ClusterBuilder body);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified cluster scoped ClusterBuilder
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to replace.</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1ClusterBuilder)</returns>
        System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1ClusterBuilder>> ReplaceClusterBuilderAsyncWithHttpInfo (string name, KpackBuildV1alpha1ClusterBuilder body);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace status of the specified cluster scoped ClusterBuilder
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>Task of KpackBuildV1alpha1ClusterBuilder</returns>
        System.Threading.Tasks.Task<KpackBuildV1alpha1ClusterBuilder> ReplaceClusterBuilderStatusAsync (string name, KpackBuildV1alpha1ClusterBuilder body);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace status of the specified cluster scoped ClusterBuilder
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1ClusterBuilder)</returns>
        System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1ClusterBuilder>> ReplaceClusterBuilderStatusAsyncWithHttpInfo (string name, KpackBuildV1alpha1ClusterBuilder body);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified cluster scoped ClusterStack
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to replace.</param>
        /// <returns>Task of KpackBuildV1alpha1ClusterStack</returns>
        System.Threading.Tasks.Task<KpackBuildV1alpha1ClusterStack> ReplaceClusterStackAsync (string name, KpackBuildV1alpha1ClusterStack body);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified cluster scoped ClusterStack
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to replace.</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1ClusterStack)</returns>
        System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1ClusterStack>> ReplaceClusterStackAsyncWithHttpInfo (string name, KpackBuildV1alpha1ClusterStack body);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace status of the specified cluster scoped ClusterStack
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>Task of KpackBuildV1alpha1ClusterStack</returns>
        System.Threading.Tasks.Task<KpackBuildV1alpha1ClusterStack> ReplaceClusterStackStatusAsync (string name, KpackBuildV1alpha1ClusterStack body);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace status of the specified cluster scoped ClusterStack
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1ClusterStack)</returns>
        System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1ClusterStack>> ReplaceClusterStackStatusAsyncWithHttpInfo (string name, KpackBuildV1alpha1ClusterStack body);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified cluster scoped ClusterStore
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to replace.</param>
        /// <returns>Task of KpackBuildV1alpha1ClusterStore</returns>
        System.Threading.Tasks.Task<KpackBuildV1alpha1ClusterStore> ReplaceClusterStoreAsync (string name, KpackBuildV1alpha1ClusterStore body);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified cluster scoped ClusterStore
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to replace.</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1ClusterStore)</returns>
        System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1ClusterStore>> ReplaceClusterStoreAsyncWithHttpInfo (string name, KpackBuildV1alpha1ClusterStore body);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace status of the specified cluster scoped ClusterStore
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>Task of KpackBuildV1alpha1ClusterStore</returns>
        System.Threading.Tasks.Task<KpackBuildV1alpha1ClusterStore> ReplaceClusterStoreStatusAsync (string name, KpackBuildV1alpha1ClusterStore body);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace status of the specified cluster scoped ClusterStore
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1ClusterStore)</returns>
        System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1ClusterStore>> ReplaceClusterStoreStatusAsyncWithHttpInfo (string name, KpackBuildV1alpha1ClusterStore body);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified namespace scoped custom object
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to replace.</param>
        /// <returns>Task of KpackBuildV1alpha1Image</returns>
        System.Threading.Tasks.Task<KpackBuildV1alpha1Image> ReplaceImageAsync (string _namespace, string name, KpackBuildV1alpha1Image body);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified namespace scoped custom object
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to replace.</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1Image)</returns>
        System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1Image>> ReplaceImageAsyncWithHttpInfo (string _namespace, string name, KpackBuildV1alpha1Image body);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace status of the specified namespace scoped Image
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>Task of KpackBuildV1alpha1Image</returns>
        System.Threading.Tasks.Task<KpackBuildV1alpha1Image> ReplaceImageStatusAsync (string _namespace, string name, KpackBuildV1alpha1Image body);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace status of the specified namespace scoped Image
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1Image)</returns>
        System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1Image>> ReplaceImageStatusAsyncWithHttpInfo (string _namespace, string name, KpackBuildV1alpha1Image body);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified namespace scoped custom object
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to replace.</param>
        /// <returns>Task of KpackBuildV1alpha1SourceResolver</returns>
        System.Threading.Tasks.Task<KpackBuildV1alpha1SourceResolver> ReplaceSourceResolverAsync (string _namespace, string name, KpackBuildV1alpha1SourceResolver body);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace the specified namespace scoped custom object
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to replace.</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1SourceResolver)</returns>
        System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1SourceResolver>> ReplaceSourceResolverAsyncWithHttpInfo (string _namespace, string name, KpackBuildV1alpha1SourceResolver body);
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace status of the specified namespace scoped SourceResolver
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>Task of KpackBuildV1alpha1SourceResolver</returns>
        System.Threading.Tasks.Task<KpackBuildV1alpha1SourceResolver> ReplaceSourceResolverStatusAsync (string _namespace, string name, KpackBuildV1alpha1SourceResolver body);

        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        /// replace status of the specified namespace scoped SourceResolver
        /// </remarks>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1SourceResolver)</returns>
        System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1SourceResolver>> ReplaceSourceResolverStatusAsyncWithHttpInfo (string _namespace, string name, KpackBuildV1alpha1SourceResolver body);
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class KpackApi : IKpackApi
    {
        private Org.OpenAPITools.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="KpackApi"/> class.
        /// </summary>
        /// <returns></returns>
        public KpackApi(String basePath)
        {
            this.Configuration = new Org.OpenAPITools.Client.Configuration { BasePath = basePath };

            ExceptionFactory = Org.OpenAPITools.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="KpackApi"/> class
        /// </summary>
        /// <returns></returns>
        public KpackApi()
        {
            this.Configuration = Org.OpenAPITools.Client.Configuration.Default;

            ExceptionFactory = Org.OpenAPITools.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="KpackApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public KpackApi(Org.OpenAPITools.Client.Configuration configuration = null)
        {
            if (configuration == null) // use the default one in Configuration
                this.Configuration = Org.OpenAPITools.Client.Configuration.Default;
            else
                this.Configuration = configuration;

            ExceptionFactory = Org.OpenAPITools.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public String GetBasePath()
        {
            return this.Configuration.ApiClient.RestClient.BaseUrl.ToString();
        }

        /// <summary>
        /// Sets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        [Obsolete("SetBasePath is deprecated, please do 'Configuration.ApiClient = new ApiClient(\"http://new-path\")' instead.")]
        public void SetBasePath(String basePath)
        {
            // do nothing
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public Org.OpenAPITools.Client.Configuration Configuration {get; set;}

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public Org.OpenAPITools.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Gets the default header.
        /// </summary>
        /// <returns>Dictionary of HTTP header</returns>
        [Obsolete("DefaultHeader is deprecated, please use Configuration.DefaultHeader instead.")]
        public IDictionary<String, String> DefaultHeader()
        {
            return new ReadOnlyDictionary<string, string>(this.Configuration.DefaultHeader);
        }

        /// <summary>
        /// Add default header.
        /// </summary>
        /// <param name="key">Header field name.</param>
        /// <param name="value">Header field value.</param>
        /// <returns></returns>
        [Obsolete("AddDefaultHeader is deprecated, please use Configuration.AddDefaultHeader instead.")]
        public void AddDefaultHeader(string key, string value)
        {
            this.Configuration.AddDefaultHeader(key, value);
        }

        /// <summary>
        ///  Creates a namespace scoped Build
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="body">The JSON schema of the Resource to create.</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>KpackBuildV1alpha1Build</returns>
        public KpackBuildV1alpha1Build CreateBuild (string _namespace, KpackBuildV1alpha1Build body, string pretty = default(string))
        {
             ApiResponse<KpackBuildV1alpha1Build> localVarResponse = CreateBuildWithHttpInfo(_namespace, body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  Creates a namespace scoped Build
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="body">The JSON schema of the Resource to create.</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1Build</returns>
        public ApiResponse<KpackBuildV1alpha1Build> CreateBuildWithHttpInfo (string _namespace, KpackBuildV1alpha1Build body, string pretty = default(string))
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling KpackApi->CreateBuild");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling KpackApi->CreateBuild");

            var localVarPath = "/apis/kpack.io/v1alpha1/namespaces/{namespace}/builds";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", this.Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "pretty", pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateBuild", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1Build>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1Build) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1Build)));
        }

        /// <summary>
        ///  Creates a namespace scoped Build
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="body">The JSON schema of the Resource to create.</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of KpackBuildV1alpha1Build</returns>
        public async System.Threading.Tasks.Task<KpackBuildV1alpha1Build> CreateBuildAsync (string _namespace, KpackBuildV1alpha1Build body, string pretty = default(string))
        {
             ApiResponse<KpackBuildV1alpha1Build> localVarResponse = await CreateBuildAsyncWithHttpInfo(_namespace, body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  Creates a namespace scoped Build
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="body">The JSON schema of the Resource to create.</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1Build)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1Build>> CreateBuildAsyncWithHttpInfo (string _namespace, KpackBuildV1alpha1Build body, string pretty = default(string))
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling KpackApi->CreateBuild");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling KpackApi->CreateBuild");

            var localVarPath = "/apis/kpack.io/v1alpha1/namespaces/{namespace}/builds";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", this.Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "pretty", pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateBuild", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1Build>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1Build) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1Build)));
        }

        /// <summary>
        ///  Creates a namespace scoped Builder
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="body">The JSON schema of the Resource to create.</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>KpackBuildV1alpha1Builder</returns>
        public KpackBuildV1alpha1Builder CreateBuilder (string _namespace, KpackBuildV1alpha1Builder body, string pretty = default(string))
        {
             ApiResponse<KpackBuildV1alpha1Builder> localVarResponse = CreateBuilderWithHttpInfo(_namespace, body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  Creates a namespace scoped Builder
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="body">The JSON schema of the Resource to create.</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1Builder</returns>
        public ApiResponse<KpackBuildV1alpha1Builder> CreateBuilderWithHttpInfo (string _namespace, KpackBuildV1alpha1Builder body, string pretty = default(string))
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling KpackApi->CreateBuilder");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling KpackApi->CreateBuilder");

            var localVarPath = "/apis/kpack.io/v1alpha1/namespaces/{namespace}/builders";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", this.Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "pretty", pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateBuilder", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1Builder>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1Builder) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1Builder)));
        }

        /// <summary>
        ///  Creates a namespace scoped Builder
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="body">The JSON schema of the Resource to create.</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of KpackBuildV1alpha1Builder</returns>
        public async System.Threading.Tasks.Task<KpackBuildV1alpha1Builder> CreateBuilderAsync (string _namespace, KpackBuildV1alpha1Builder body, string pretty = default(string))
        {
             ApiResponse<KpackBuildV1alpha1Builder> localVarResponse = await CreateBuilderAsyncWithHttpInfo(_namespace, body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  Creates a namespace scoped Builder
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="body">The JSON schema of the Resource to create.</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1Builder)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1Builder>> CreateBuilderAsyncWithHttpInfo (string _namespace, KpackBuildV1alpha1Builder body, string pretty = default(string))
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling KpackApi->CreateBuilder");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling KpackApi->CreateBuilder");

            var localVarPath = "/apis/kpack.io/v1alpha1/namespaces/{namespace}/builders";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", this.Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "pretty", pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateBuilder", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1Builder>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1Builder) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1Builder)));
        }

        /// <summary>
        ///  Creates a cluster scoped ClusterBuilder
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The JSON schema of the Resource to create.</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>KpackBuildV1alpha1ClusterBuilder</returns>
        public KpackBuildV1alpha1ClusterBuilder CreateClusterBuilder (KpackBuildV1alpha1ClusterBuilder body, string pretty = default(string))
        {
             ApiResponse<KpackBuildV1alpha1ClusterBuilder> localVarResponse = CreateClusterBuilderWithHttpInfo(body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  Creates a cluster scoped ClusterBuilder
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The JSON schema of the Resource to create.</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1ClusterBuilder</returns>
        public ApiResponse<KpackBuildV1alpha1ClusterBuilder> CreateClusterBuilderWithHttpInfo (KpackBuildV1alpha1ClusterBuilder body, string pretty = default(string))
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling KpackApi->CreateClusterBuilder");

            var localVarPath = "/apis/kpack.io/v1alpha1/clusterbuilders";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (pretty != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "pretty", pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateClusterBuilder", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1ClusterBuilder>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1ClusterBuilder) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1ClusterBuilder)));
        }

        /// <summary>
        ///  Creates a cluster scoped ClusterBuilder
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The JSON schema of the Resource to create.</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of KpackBuildV1alpha1ClusterBuilder</returns>
        public async System.Threading.Tasks.Task<KpackBuildV1alpha1ClusterBuilder> CreateClusterBuilderAsync (KpackBuildV1alpha1ClusterBuilder body, string pretty = default(string))
        {
             ApiResponse<KpackBuildV1alpha1ClusterBuilder> localVarResponse = await CreateClusterBuilderAsyncWithHttpInfo(body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  Creates a cluster scoped ClusterBuilder
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The JSON schema of the Resource to create.</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1ClusterBuilder)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1ClusterBuilder>> CreateClusterBuilderAsyncWithHttpInfo (KpackBuildV1alpha1ClusterBuilder body, string pretty = default(string))
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling KpackApi->CreateClusterBuilder");

            var localVarPath = "/apis/kpack.io/v1alpha1/clusterbuilders";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (pretty != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "pretty", pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateClusterBuilder", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1ClusterBuilder>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1ClusterBuilder) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1ClusterBuilder)));
        }

        /// <summary>
        ///  Creates a cluster scoped ClusterStack
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The JSON schema of the Resource to create.</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>KpackBuildV1alpha1ClusterStack</returns>
        public KpackBuildV1alpha1ClusterStack CreateClusterStack (KpackBuildV1alpha1ClusterStack body, string pretty = default(string))
        {
             ApiResponse<KpackBuildV1alpha1ClusterStack> localVarResponse = CreateClusterStackWithHttpInfo(body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  Creates a cluster scoped ClusterStack
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The JSON schema of the Resource to create.</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1ClusterStack</returns>
        public ApiResponse<KpackBuildV1alpha1ClusterStack> CreateClusterStackWithHttpInfo (KpackBuildV1alpha1ClusterStack body, string pretty = default(string))
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling KpackApi->CreateClusterStack");

            var localVarPath = "/apis/kpack.io/v1alpha1/clusterstacks";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (pretty != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "pretty", pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateClusterStack", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1ClusterStack>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1ClusterStack) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1ClusterStack)));
        }

        /// <summary>
        ///  Creates a cluster scoped ClusterStack
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The JSON schema of the Resource to create.</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of KpackBuildV1alpha1ClusterStack</returns>
        public async System.Threading.Tasks.Task<KpackBuildV1alpha1ClusterStack> CreateClusterStackAsync (KpackBuildV1alpha1ClusterStack body, string pretty = default(string))
        {
             ApiResponse<KpackBuildV1alpha1ClusterStack> localVarResponse = await CreateClusterStackAsyncWithHttpInfo(body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  Creates a cluster scoped ClusterStack
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The JSON schema of the Resource to create.</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1ClusterStack)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1ClusterStack>> CreateClusterStackAsyncWithHttpInfo (KpackBuildV1alpha1ClusterStack body, string pretty = default(string))
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling KpackApi->CreateClusterStack");

            var localVarPath = "/apis/kpack.io/v1alpha1/clusterstacks";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (pretty != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "pretty", pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateClusterStack", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1ClusterStack>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1ClusterStack) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1ClusterStack)));
        }

        /// <summary>
        ///  Creates a cluster scoped ClusterStore
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The JSON schema of the Resource to create.</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>KpackBuildV1alpha1ClusterStore</returns>
        public KpackBuildV1alpha1ClusterStore CreateClusterStore (KpackBuildV1alpha1ClusterStore body, string pretty = default(string))
        {
             ApiResponse<KpackBuildV1alpha1ClusterStore> localVarResponse = CreateClusterStoreWithHttpInfo(body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  Creates a cluster scoped ClusterStore
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The JSON schema of the Resource to create.</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1ClusterStore</returns>
        public ApiResponse<KpackBuildV1alpha1ClusterStore> CreateClusterStoreWithHttpInfo (KpackBuildV1alpha1ClusterStore body, string pretty = default(string))
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling KpackApi->CreateClusterStore");

            var localVarPath = "/apis/kpack.io/v1alpha1/clusterstores";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (pretty != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "pretty", pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateClusterStore", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1ClusterStore>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1ClusterStore) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1ClusterStore)));
        }

        /// <summary>
        ///  Creates a cluster scoped ClusterStore
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The JSON schema of the Resource to create.</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of KpackBuildV1alpha1ClusterStore</returns>
        public async System.Threading.Tasks.Task<KpackBuildV1alpha1ClusterStore> CreateClusterStoreAsync (KpackBuildV1alpha1ClusterStore body, string pretty = default(string))
        {
             ApiResponse<KpackBuildV1alpha1ClusterStore> localVarResponse = await CreateClusterStoreAsyncWithHttpInfo(body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  Creates a cluster scoped ClusterStore
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="body">The JSON schema of the Resource to create.</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1ClusterStore)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1ClusterStore>> CreateClusterStoreAsyncWithHttpInfo (KpackBuildV1alpha1ClusterStore body, string pretty = default(string))
        {
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling KpackApi->CreateClusterStore");

            var localVarPath = "/apis/kpack.io/v1alpha1/clusterstores";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (pretty != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "pretty", pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateClusterStore", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1ClusterStore>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1ClusterStore) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1ClusterStore)));
        }

        /// <summary>
        ///  Creates a namespace scoped Image
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="body">The JSON schema of the Resource to create.</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>KpackBuildV1alpha1Image</returns>
        public KpackBuildV1alpha1Image CreateImage (string _namespace, KpackBuildV1alpha1Image body, string pretty = default(string))
        {
             ApiResponse<KpackBuildV1alpha1Image> localVarResponse = CreateImageWithHttpInfo(_namespace, body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  Creates a namespace scoped Image
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="body">The JSON schema of the Resource to create.</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1Image</returns>
        public ApiResponse<KpackBuildV1alpha1Image> CreateImageWithHttpInfo (string _namespace, KpackBuildV1alpha1Image body, string pretty = default(string))
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling KpackApi->CreateImage");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling KpackApi->CreateImage");

            var localVarPath = "/apis/kpack.io/v1alpha1/namespaces/{namespace}/images";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", this.Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "pretty", pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateImage", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1Image>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1Image) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1Image)));
        }

        /// <summary>
        ///  Creates a namespace scoped Image
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="body">The JSON schema of the Resource to create.</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of KpackBuildV1alpha1Image</returns>
        public async System.Threading.Tasks.Task<KpackBuildV1alpha1Image> CreateImageAsync (string _namespace, KpackBuildV1alpha1Image body, string pretty = default(string))
        {
             ApiResponse<KpackBuildV1alpha1Image> localVarResponse = await CreateImageAsyncWithHttpInfo(_namespace, body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  Creates a namespace scoped Image
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="body">The JSON schema of the Resource to create.</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1Image)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1Image>> CreateImageAsyncWithHttpInfo (string _namespace, KpackBuildV1alpha1Image body, string pretty = default(string))
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling KpackApi->CreateImage");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling KpackApi->CreateImage");

            var localVarPath = "/apis/kpack.io/v1alpha1/namespaces/{namespace}/images";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", this.Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "pretty", pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateImage", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1Image>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1Image) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1Image)));
        }

        /// <summary>
        ///  Creates a namespace scoped SourceResolver
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="body">The JSON schema of the Resource to create.</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>KpackBuildV1alpha1SourceResolver</returns>
        public KpackBuildV1alpha1SourceResolver CreateSourceResolver (string _namespace, KpackBuildV1alpha1SourceResolver body, string pretty = default(string))
        {
             ApiResponse<KpackBuildV1alpha1SourceResolver> localVarResponse = CreateSourceResolverWithHttpInfo(_namespace, body, pretty);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  Creates a namespace scoped SourceResolver
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="body">The JSON schema of the Resource to create.</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1SourceResolver</returns>
        public ApiResponse<KpackBuildV1alpha1SourceResolver> CreateSourceResolverWithHttpInfo (string _namespace, KpackBuildV1alpha1SourceResolver body, string pretty = default(string))
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling KpackApi->CreateSourceResolver");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling KpackApi->CreateSourceResolver");

            var localVarPath = "/apis/kpack.io/v1alpha1/namespaces/{namespace}/sourceresolvers";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", this.Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "pretty", pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateSourceResolver", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1SourceResolver>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1SourceResolver) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1SourceResolver)));
        }

        /// <summary>
        ///  Creates a namespace scoped SourceResolver
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="body">The JSON schema of the Resource to create.</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of KpackBuildV1alpha1SourceResolver</returns>
        public async System.Threading.Tasks.Task<KpackBuildV1alpha1SourceResolver> CreateSourceResolverAsync (string _namespace, KpackBuildV1alpha1SourceResolver body, string pretty = default(string))
        {
             ApiResponse<KpackBuildV1alpha1SourceResolver> localVarResponse = await CreateSourceResolverAsyncWithHttpInfo(_namespace, body, pretty);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  Creates a namespace scoped SourceResolver
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="body">The JSON schema of the Resource to create.</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1SourceResolver)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1SourceResolver>> CreateSourceResolverAsyncWithHttpInfo (string _namespace, KpackBuildV1alpha1SourceResolver body, string pretty = default(string))
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling KpackApi->CreateSourceResolver");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling KpackApi->CreateSourceResolver");

            var localVarPath = "/apis/kpack.io/v1alpha1/namespaces/{namespace}/sourceresolvers";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", this.Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "pretty", pretty)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateSourceResolver", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1SourceResolver>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1SourceResolver) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1SourceResolver)));
        }

        /// <summary>
        ///  Deletes the specified namespace scoped Build
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <returns>IoK8sApimachineryPkgApisMetaV1Status</returns>
        public IoK8sApimachineryPkgApisMetaV1Status DeleteBuild (string _namespace, string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), IoK8sApimachineryPkgApisMetaV1DeleteOptions body = default(IoK8sApimachineryPkgApisMetaV1DeleteOptions))
        {
             ApiResponse<IoK8sApimachineryPkgApisMetaV1Status> localVarResponse = DeleteBuildWithHttpInfo(_namespace, name, gracePeriodSeconds, orphanDependents, propagationPolicy, body);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  Deletes the specified namespace scoped Build
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <returns>ApiResponse of IoK8sApimachineryPkgApisMetaV1Status</returns>
        public ApiResponse<IoK8sApimachineryPkgApisMetaV1Status> DeleteBuildWithHttpInfo (string _namespace, string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), IoK8sApimachineryPkgApisMetaV1DeleteOptions body = default(IoK8sApimachineryPkgApisMetaV1DeleteOptions))
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling KpackApi->DeleteBuild");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->DeleteBuild");

            var localVarPath = "/apis/kpack.io/v1alpha1/namespaces/{namespace}/builds/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", this.Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (gracePeriodSeconds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "gracePeriodSeconds", gracePeriodSeconds)); // query parameter
            if (orphanDependents != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "orphanDependents", orphanDependents)); // query parameter
            if (propagationPolicy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "propagationPolicy", propagationPolicy)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteBuild", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (IoK8sApimachineryPkgApisMetaV1Status) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(IoK8sApimachineryPkgApisMetaV1Status)));
        }

        /// <summary>
        ///  Deletes the specified namespace scoped Build
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <returns>Task of IoK8sApimachineryPkgApisMetaV1Status</returns>
        public async System.Threading.Tasks.Task<IoK8sApimachineryPkgApisMetaV1Status> DeleteBuildAsync (string _namespace, string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), IoK8sApimachineryPkgApisMetaV1DeleteOptions body = default(IoK8sApimachineryPkgApisMetaV1DeleteOptions))
        {
             ApiResponse<IoK8sApimachineryPkgApisMetaV1Status> localVarResponse = await DeleteBuildAsyncWithHttpInfo(_namespace, name, gracePeriodSeconds, orphanDependents, propagationPolicy, body);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  Deletes the specified namespace scoped Build
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <returns>Task of ApiResponse (IoK8sApimachineryPkgApisMetaV1Status)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>> DeleteBuildAsyncWithHttpInfo (string _namespace, string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), IoK8sApimachineryPkgApisMetaV1DeleteOptions body = default(IoK8sApimachineryPkgApisMetaV1DeleteOptions))
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling KpackApi->DeleteBuild");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->DeleteBuild");

            var localVarPath = "/apis/kpack.io/v1alpha1/namespaces/{namespace}/builds/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", this.Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (gracePeriodSeconds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "gracePeriodSeconds", gracePeriodSeconds)); // query parameter
            if (orphanDependents != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "orphanDependents", orphanDependents)); // query parameter
            if (propagationPolicy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "propagationPolicy", propagationPolicy)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteBuild", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (IoK8sApimachineryPkgApisMetaV1Status) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(IoK8sApimachineryPkgApisMetaV1Status)));
        }

        /// <summary>
        ///  Deletes the specified namespace scoped Builder
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <returns>IoK8sApimachineryPkgApisMetaV1Status</returns>
        public IoK8sApimachineryPkgApisMetaV1Status DeleteBuilder (string _namespace, string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), IoK8sApimachineryPkgApisMetaV1DeleteOptions body = default(IoK8sApimachineryPkgApisMetaV1DeleteOptions))
        {
             ApiResponse<IoK8sApimachineryPkgApisMetaV1Status> localVarResponse = DeleteBuilderWithHttpInfo(_namespace, name, gracePeriodSeconds, orphanDependents, propagationPolicy, body);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  Deletes the specified namespace scoped Builder
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <returns>ApiResponse of IoK8sApimachineryPkgApisMetaV1Status</returns>
        public ApiResponse<IoK8sApimachineryPkgApisMetaV1Status> DeleteBuilderWithHttpInfo (string _namespace, string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), IoK8sApimachineryPkgApisMetaV1DeleteOptions body = default(IoK8sApimachineryPkgApisMetaV1DeleteOptions))
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling KpackApi->DeleteBuilder");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->DeleteBuilder");

            var localVarPath = "/apis/kpack.io/v1alpha1/namespaces/{namespace}/builders/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", this.Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (gracePeriodSeconds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "gracePeriodSeconds", gracePeriodSeconds)); // query parameter
            if (orphanDependents != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "orphanDependents", orphanDependents)); // query parameter
            if (propagationPolicy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "propagationPolicy", propagationPolicy)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteBuilder", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (IoK8sApimachineryPkgApisMetaV1Status) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(IoK8sApimachineryPkgApisMetaV1Status)));
        }

        /// <summary>
        ///  Deletes the specified namespace scoped Builder
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <returns>Task of IoK8sApimachineryPkgApisMetaV1Status</returns>
        public async System.Threading.Tasks.Task<IoK8sApimachineryPkgApisMetaV1Status> DeleteBuilderAsync (string _namespace, string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), IoK8sApimachineryPkgApisMetaV1DeleteOptions body = default(IoK8sApimachineryPkgApisMetaV1DeleteOptions))
        {
             ApiResponse<IoK8sApimachineryPkgApisMetaV1Status> localVarResponse = await DeleteBuilderAsyncWithHttpInfo(_namespace, name, gracePeriodSeconds, orphanDependents, propagationPolicy, body);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  Deletes the specified namespace scoped Builder
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <returns>Task of ApiResponse (IoK8sApimachineryPkgApisMetaV1Status)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>> DeleteBuilderAsyncWithHttpInfo (string _namespace, string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), IoK8sApimachineryPkgApisMetaV1DeleteOptions body = default(IoK8sApimachineryPkgApisMetaV1DeleteOptions))
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling KpackApi->DeleteBuilder");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->DeleteBuilder");

            var localVarPath = "/apis/kpack.io/v1alpha1/namespaces/{namespace}/builders/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", this.Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (gracePeriodSeconds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "gracePeriodSeconds", gracePeriodSeconds)); // query parameter
            if (orphanDependents != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "orphanDependents", orphanDependents)); // query parameter
            if (propagationPolicy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "propagationPolicy", propagationPolicy)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteBuilder", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (IoK8sApimachineryPkgApisMetaV1Status) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(IoK8sApimachineryPkgApisMetaV1Status)));
        }

        /// <summary>
        ///  Deletes the specified cluster scoped ClusterBuilder
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <returns>IoK8sApimachineryPkgApisMetaV1Status</returns>
        public IoK8sApimachineryPkgApisMetaV1Status DeleteClusterBuilder (string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), IoK8sApimachineryPkgApisMetaV1DeleteOptions body = default(IoK8sApimachineryPkgApisMetaV1DeleteOptions))
        {
             ApiResponse<IoK8sApimachineryPkgApisMetaV1Status> localVarResponse = DeleteClusterBuilderWithHttpInfo(name, gracePeriodSeconds, orphanDependents, propagationPolicy, body);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  Deletes the specified cluster scoped ClusterBuilder
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <returns>ApiResponse of IoK8sApimachineryPkgApisMetaV1Status</returns>
        public ApiResponse<IoK8sApimachineryPkgApisMetaV1Status> DeleteClusterBuilderWithHttpInfo (string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), IoK8sApimachineryPkgApisMetaV1DeleteOptions body = default(IoK8sApimachineryPkgApisMetaV1DeleteOptions))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->DeleteClusterBuilder");

            var localVarPath = "/apis/kpack.io/v1alpha1/clusterbuilders/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (gracePeriodSeconds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "gracePeriodSeconds", gracePeriodSeconds)); // query parameter
            if (orphanDependents != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "orphanDependents", orphanDependents)); // query parameter
            if (propagationPolicy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "propagationPolicy", propagationPolicy)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteClusterBuilder", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (IoK8sApimachineryPkgApisMetaV1Status) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(IoK8sApimachineryPkgApisMetaV1Status)));
        }

        /// <summary>
        ///  Deletes the specified cluster scoped ClusterBuilder
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <returns>Task of IoK8sApimachineryPkgApisMetaV1Status</returns>
        public async System.Threading.Tasks.Task<IoK8sApimachineryPkgApisMetaV1Status> DeleteClusterBuilderAsync (string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), IoK8sApimachineryPkgApisMetaV1DeleteOptions body = default(IoK8sApimachineryPkgApisMetaV1DeleteOptions))
        {
             ApiResponse<IoK8sApimachineryPkgApisMetaV1Status> localVarResponse = await DeleteClusterBuilderAsyncWithHttpInfo(name, gracePeriodSeconds, orphanDependents, propagationPolicy, body);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  Deletes the specified cluster scoped ClusterBuilder
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <returns>Task of ApiResponse (IoK8sApimachineryPkgApisMetaV1Status)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>> DeleteClusterBuilderAsyncWithHttpInfo (string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), IoK8sApimachineryPkgApisMetaV1DeleteOptions body = default(IoK8sApimachineryPkgApisMetaV1DeleteOptions))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->DeleteClusterBuilder");

            var localVarPath = "/apis/kpack.io/v1alpha1/clusterbuilders/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (gracePeriodSeconds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "gracePeriodSeconds", gracePeriodSeconds)); // query parameter
            if (orphanDependents != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "orphanDependents", orphanDependents)); // query parameter
            if (propagationPolicy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "propagationPolicy", propagationPolicy)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteClusterBuilder", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (IoK8sApimachineryPkgApisMetaV1Status) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(IoK8sApimachineryPkgApisMetaV1Status)));
        }

        /// <summary>
        ///  Deletes the specified cluster scoped ClusterStack
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <returns>IoK8sApimachineryPkgApisMetaV1Status</returns>
        public IoK8sApimachineryPkgApisMetaV1Status DeleteClusterStack (string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), IoK8sApimachineryPkgApisMetaV1DeleteOptions body = default(IoK8sApimachineryPkgApisMetaV1DeleteOptions))
        {
             ApiResponse<IoK8sApimachineryPkgApisMetaV1Status> localVarResponse = DeleteClusterStackWithHttpInfo(name, gracePeriodSeconds, orphanDependents, propagationPolicy, body);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  Deletes the specified cluster scoped ClusterStack
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <returns>ApiResponse of IoK8sApimachineryPkgApisMetaV1Status</returns>
        public ApiResponse<IoK8sApimachineryPkgApisMetaV1Status> DeleteClusterStackWithHttpInfo (string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), IoK8sApimachineryPkgApisMetaV1DeleteOptions body = default(IoK8sApimachineryPkgApisMetaV1DeleteOptions))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->DeleteClusterStack");

            var localVarPath = "/apis/kpack.io/v1alpha1/clusterstacks/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (gracePeriodSeconds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "gracePeriodSeconds", gracePeriodSeconds)); // query parameter
            if (orphanDependents != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "orphanDependents", orphanDependents)); // query parameter
            if (propagationPolicy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "propagationPolicy", propagationPolicy)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteClusterStack", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (IoK8sApimachineryPkgApisMetaV1Status) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(IoK8sApimachineryPkgApisMetaV1Status)));
        }

        /// <summary>
        ///  Deletes the specified cluster scoped ClusterStack
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <returns>Task of IoK8sApimachineryPkgApisMetaV1Status</returns>
        public async System.Threading.Tasks.Task<IoK8sApimachineryPkgApisMetaV1Status> DeleteClusterStackAsync (string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), IoK8sApimachineryPkgApisMetaV1DeleteOptions body = default(IoK8sApimachineryPkgApisMetaV1DeleteOptions))
        {
             ApiResponse<IoK8sApimachineryPkgApisMetaV1Status> localVarResponse = await DeleteClusterStackAsyncWithHttpInfo(name, gracePeriodSeconds, orphanDependents, propagationPolicy, body);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  Deletes the specified cluster scoped ClusterStack
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <returns>Task of ApiResponse (IoK8sApimachineryPkgApisMetaV1Status)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>> DeleteClusterStackAsyncWithHttpInfo (string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), IoK8sApimachineryPkgApisMetaV1DeleteOptions body = default(IoK8sApimachineryPkgApisMetaV1DeleteOptions))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->DeleteClusterStack");

            var localVarPath = "/apis/kpack.io/v1alpha1/clusterstacks/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (gracePeriodSeconds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "gracePeriodSeconds", gracePeriodSeconds)); // query parameter
            if (orphanDependents != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "orphanDependents", orphanDependents)); // query parameter
            if (propagationPolicy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "propagationPolicy", propagationPolicy)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteClusterStack", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (IoK8sApimachineryPkgApisMetaV1Status) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(IoK8sApimachineryPkgApisMetaV1Status)));
        }

        /// <summary>
        ///  Deletes the specified cluster scoped ClusterStore
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <returns>IoK8sApimachineryPkgApisMetaV1Status</returns>
        public IoK8sApimachineryPkgApisMetaV1Status DeleteClusterStore (string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), IoK8sApimachineryPkgApisMetaV1DeleteOptions body = default(IoK8sApimachineryPkgApisMetaV1DeleteOptions))
        {
             ApiResponse<IoK8sApimachineryPkgApisMetaV1Status> localVarResponse = DeleteClusterStoreWithHttpInfo(name, gracePeriodSeconds, orphanDependents, propagationPolicy, body);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  Deletes the specified cluster scoped ClusterStore
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <returns>ApiResponse of IoK8sApimachineryPkgApisMetaV1Status</returns>
        public ApiResponse<IoK8sApimachineryPkgApisMetaV1Status> DeleteClusterStoreWithHttpInfo (string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), IoK8sApimachineryPkgApisMetaV1DeleteOptions body = default(IoK8sApimachineryPkgApisMetaV1DeleteOptions))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->DeleteClusterStore");

            var localVarPath = "/apis/kpack.io/v1alpha1/clusterstores/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (gracePeriodSeconds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "gracePeriodSeconds", gracePeriodSeconds)); // query parameter
            if (orphanDependents != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "orphanDependents", orphanDependents)); // query parameter
            if (propagationPolicy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "propagationPolicy", propagationPolicy)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteClusterStore", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (IoK8sApimachineryPkgApisMetaV1Status) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(IoK8sApimachineryPkgApisMetaV1Status)));
        }

        /// <summary>
        ///  Deletes the specified cluster scoped ClusterStore
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <returns>Task of IoK8sApimachineryPkgApisMetaV1Status</returns>
        public async System.Threading.Tasks.Task<IoK8sApimachineryPkgApisMetaV1Status> DeleteClusterStoreAsync (string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), IoK8sApimachineryPkgApisMetaV1DeleteOptions body = default(IoK8sApimachineryPkgApisMetaV1DeleteOptions))
        {
             ApiResponse<IoK8sApimachineryPkgApisMetaV1Status> localVarResponse = await DeleteClusterStoreAsyncWithHttpInfo(name, gracePeriodSeconds, orphanDependents, propagationPolicy, body);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  Deletes the specified cluster scoped ClusterStore
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <returns>Task of ApiResponse (IoK8sApimachineryPkgApisMetaV1Status)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>> DeleteClusterStoreAsyncWithHttpInfo (string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), IoK8sApimachineryPkgApisMetaV1DeleteOptions body = default(IoK8sApimachineryPkgApisMetaV1DeleteOptions))
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->DeleteClusterStore");

            var localVarPath = "/apis/kpack.io/v1alpha1/clusterstores/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (gracePeriodSeconds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "gracePeriodSeconds", gracePeriodSeconds)); // query parameter
            if (orphanDependents != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "orphanDependents", orphanDependents)); // query parameter
            if (propagationPolicy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "propagationPolicy", propagationPolicy)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteClusterStore", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (IoK8sApimachineryPkgApisMetaV1Status) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(IoK8sApimachineryPkgApisMetaV1Status)));
        }

        /// <summary>
        ///  Deletes the specified namespace scoped Image
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <returns>IoK8sApimachineryPkgApisMetaV1Status</returns>
        public IoK8sApimachineryPkgApisMetaV1Status DeleteImage (string _namespace, string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), IoK8sApimachineryPkgApisMetaV1DeleteOptions body = default(IoK8sApimachineryPkgApisMetaV1DeleteOptions))
        {
             ApiResponse<IoK8sApimachineryPkgApisMetaV1Status> localVarResponse = DeleteImageWithHttpInfo(_namespace, name, gracePeriodSeconds, orphanDependents, propagationPolicy, body);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  Deletes the specified namespace scoped Image
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <returns>ApiResponse of IoK8sApimachineryPkgApisMetaV1Status</returns>
        public ApiResponse<IoK8sApimachineryPkgApisMetaV1Status> DeleteImageWithHttpInfo (string _namespace, string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), IoK8sApimachineryPkgApisMetaV1DeleteOptions body = default(IoK8sApimachineryPkgApisMetaV1DeleteOptions))
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling KpackApi->DeleteImage");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->DeleteImage");

            var localVarPath = "/apis/kpack.io/v1alpha1/namespaces/{namespace}/images/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", this.Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (gracePeriodSeconds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "gracePeriodSeconds", gracePeriodSeconds)); // query parameter
            if (orphanDependents != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "orphanDependents", orphanDependents)); // query parameter
            if (propagationPolicy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "propagationPolicy", propagationPolicy)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteImage", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (IoK8sApimachineryPkgApisMetaV1Status) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(IoK8sApimachineryPkgApisMetaV1Status)));
        }

        /// <summary>
        ///  Deletes the specified namespace scoped Image
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <returns>Task of IoK8sApimachineryPkgApisMetaV1Status</returns>
        public async System.Threading.Tasks.Task<IoK8sApimachineryPkgApisMetaV1Status> DeleteImageAsync (string _namespace, string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), IoK8sApimachineryPkgApisMetaV1DeleteOptions body = default(IoK8sApimachineryPkgApisMetaV1DeleteOptions))
        {
             ApiResponse<IoK8sApimachineryPkgApisMetaV1Status> localVarResponse = await DeleteImageAsyncWithHttpInfo(_namespace, name, gracePeriodSeconds, orphanDependents, propagationPolicy, body);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  Deletes the specified namespace scoped Image
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <returns>Task of ApiResponse (IoK8sApimachineryPkgApisMetaV1Status)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>> DeleteImageAsyncWithHttpInfo (string _namespace, string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), IoK8sApimachineryPkgApisMetaV1DeleteOptions body = default(IoK8sApimachineryPkgApisMetaV1DeleteOptions))
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling KpackApi->DeleteImage");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->DeleteImage");

            var localVarPath = "/apis/kpack.io/v1alpha1/namespaces/{namespace}/images/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", this.Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (gracePeriodSeconds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "gracePeriodSeconds", gracePeriodSeconds)); // query parameter
            if (orphanDependents != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "orphanDependents", orphanDependents)); // query parameter
            if (propagationPolicy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "propagationPolicy", propagationPolicy)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteImage", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (IoK8sApimachineryPkgApisMetaV1Status) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(IoK8sApimachineryPkgApisMetaV1Status)));
        }

        /// <summary>
        ///  Deletes the specified namespace scoped SourceResolver
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <returns>IoK8sApimachineryPkgApisMetaV1Status</returns>
        public IoK8sApimachineryPkgApisMetaV1Status DeleteSourceResolver (string _namespace, string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), IoK8sApimachineryPkgApisMetaV1DeleteOptions body = default(IoK8sApimachineryPkgApisMetaV1DeleteOptions))
        {
             ApiResponse<IoK8sApimachineryPkgApisMetaV1Status> localVarResponse = DeleteSourceResolverWithHttpInfo(_namespace, name, gracePeriodSeconds, orphanDependents, propagationPolicy, body);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  Deletes the specified namespace scoped SourceResolver
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <returns>ApiResponse of IoK8sApimachineryPkgApisMetaV1Status</returns>
        public ApiResponse<IoK8sApimachineryPkgApisMetaV1Status> DeleteSourceResolverWithHttpInfo (string _namespace, string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), IoK8sApimachineryPkgApisMetaV1DeleteOptions body = default(IoK8sApimachineryPkgApisMetaV1DeleteOptions))
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling KpackApi->DeleteSourceResolver");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->DeleteSourceResolver");

            var localVarPath = "/apis/kpack.io/v1alpha1/namespaces/{namespace}/sourceresolvers/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", this.Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (gracePeriodSeconds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "gracePeriodSeconds", gracePeriodSeconds)); // query parameter
            if (orphanDependents != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "orphanDependents", orphanDependents)); // query parameter
            if (propagationPolicy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "propagationPolicy", propagationPolicy)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteSourceResolver", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (IoK8sApimachineryPkgApisMetaV1Status) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(IoK8sApimachineryPkgApisMetaV1Status)));
        }

        /// <summary>
        ///  Deletes the specified namespace scoped SourceResolver
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <returns>Task of IoK8sApimachineryPkgApisMetaV1Status</returns>
        public async System.Threading.Tasks.Task<IoK8sApimachineryPkgApisMetaV1Status> DeleteSourceResolverAsync (string _namespace, string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), IoK8sApimachineryPkgApisMetaV1DeleteOptions body = default(IoK8sApimachineryPkgApisMetaV1DeleteOptions))
        {
             ApiResponse<IoK8sApimachineryPkgApisMetaV1Status> localVarResponse = await DeleteSourceResolverAsyncWithHttpInfo(_namespace, name, gracePeriodSeconds, orphanDependents, propagationPolicy, body);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  Deletes the specified namespace scoped SourceResolver
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="gracePeriodSeconds">The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately. (optional)</param>
        /// <param name="orphanDependents">Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both. (optional)</param>
        /// <param name="propagationPolicy">Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. (optional)</param>
        /// <param name="body"> (optional)</param>
        /// <returns>Task of ApiResponse (IoK8sApimachineryPkgApisMetaV1Status)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>> DeleteSourceResolverAsyncWithHttpInfo (string _namespace, string name, int? gracePeriodSeconds = default(int?), bool? orphanDependents = default(bool?), string propagationPolicy = default(string), IoK8sApimachineryPkgApisMetaV1DeleteOptions body = default(IoK8sApimachineryPkgApisMetaV1DeleteOptions))
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling KpackApi->DeleteSourceResolver");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->DeleteSourceResolver");

            var localVarPath = "/apis/kpack.io/v1alpha1/namespaces/{namespace}/sourceresolvers/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", this.Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (gracePeriodSeconds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "gracePeriodSeconds", gracePeriodSeconds)); // query parameter
            if (orphanDependents != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "orphanDependents", orphanDependents)); // query parameter
            if (propagationPolicy != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "propagationPolicy", propagationPolicy)); // query parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteSourceResolver", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (IoK8sApimachineryPkgApisMetaV1Status) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(IoK8sApimachineryPkgApisMetaV1Status)));
        }

        /// <summary>
        ///  Returns a namespace scoped custom object
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>KpackBuildV1alpha1Build</returns>
        public KpackBuildV1alpha1Build GetBuild (string _namespace, string name)
        {
             ApiResponse<KpackBuildV1alpha1Build> localVarResponse = GetBuildWithHttpInfo(_namespace, name);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  Returns a namespace scoped custom object
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1Build</returns>
        public ApiResponse<KpackBuildV1alpha1Build> GetBuildWithHttpInfo (string _namespace, string name)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling KpackApi->GetBuild");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->GetBuild");

            var localVarPath = "/apis/kpack.io/v1alpha1/namespaces/{namespace}/builds/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", this.Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetBuild", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1Build>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1Build) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1Build)));
        }

        /// <summary>
        ///  Returns a namespace scoped custom object
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>Task of KpackBuildV1alpha1Build</returns>
        public async System.Threading.Tasks.Task<KpackBuildV1alpha1Build> GetBuildAsync (string _namespace, string name)
        {
             ApiResponse<KpackBuildV1alpha1Build> localVarResponse = await GetBuildAsyncWithHttpInfo(_namespace, name);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  Returns a namespace scoped custom object
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1Build)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1Build>> GetBuildAsyncWithHttpInfo (string _namespace, string name)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling KpackApi->GetBuild");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->GetBuild");

            var localVarPath = "/apis/kpack.io/v1alpha1/namespaces/{namespace}/builds/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", this.Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetBuild", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1Build>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1Build) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1Build)));
        }

        /// <summary>
        ///  read status of the specified namespace scoped Build
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>KpackBuildV1alpha1Build</returns>
        public KpackBuildV1alpha1Build GetBuildStatus (string _namespace, string name)
        {
             ApiResponse<KpackBuildV1alpha1Build> localVarResponse = GetBuildStatusWithHttpInfo(_namespace, name);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  read status of the specified namespace scoped Build
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1Build</returns>
        public ApiResponse<KpackBuildV1alpha1Build> GetBuildStatusWithHttpInfo (string _namespace, string name)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling KpackApi->GetBuildStatus");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->GetBuildStatus");

            var localVarPath = "/apis/kpack.io/v1alpha1/namespaces/{namespace}/builds/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", this.Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetBuildStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1Build>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1Build) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1Build)));
        }

        /// <summary>
        ///  read status of the specified namespace scoped Build
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>Task of KpackBuildV1alpha1Build</returns>
        public async System.Threading.Tasks.Task<KpackBuildV1alpha1Build> GetBuildStatusAsync (string _namespace, string name)
        {
             ApiResponse<KpackBuildV1alpha1Build> localVarResponse = await GetBuildStatusAsyncWithHttpInfo(_namespace, name);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  read status of the specified namespace scoped Build
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1Build)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1Build>> GetBuildStatusAsyncWithHttpInfo (string _namespace, string name)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling KpackApi->GetBuildStatus");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->GetBuildStatus");

            var localVarPath = "/apis/kpack.io/v1alpha1/namespaces/{namespace}/builds/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", this.Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetBuildStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1Build>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1Build) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1Build)));
        }

        /// <summary>
        ///  Returns a namespace scoped custom object
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>KpackBuildV1alpha1Builder</returns>
        public KpackBuildV1alpha1Builder GetBuilder (string _namespace, string name)
        {
             ApiResponse<KpackBuildV1alpha1Builder> localVarResponse = GetBuilderWithHttpInfo(_namespace, name);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  Returns a namespace scoped custom object
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1Builder</returns>
        public ApiResponse<KpackBuildV1alpha1Builder> GetBuilderWithHttpInfo (string _namespace, string name)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling KpackApi->GetBuilder");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->GetBuilder");

            var localVarPath = "/apis/kpack.io/v1alpha1/namespaces/{namespace}/builders/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", this.Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetBuilder", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1Builder>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1Builder) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1Builder)));
        }

        /// <summary>
        ///  Returns a namespace scoped custom object
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>Task of KpackBuildV1alpha1Builder</returns>
        public async System.Threading.Tasks.Task<KpackBuildV1alpha1Builder> GetBuilderAsync (string _namespace, string name)
        {
             ApiResponse<KpackBuildV1alpha1Builder> localVarResponse = await GetBuilderAsyncWithHttpInfo(_namespace, name);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  Returns a namespace scoped custom object
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1Builder)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1Builder>> GetBuilderAsyncWithHttpInfo (string _namespace, string name)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling KpackApi->GetBuilder");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->GetBuilder");

            var localVarPath = "/apis/kpack.io/v1alpha1/namespaces/{namespace}/builders/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", this.Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetBuilder", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1Builder>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1Builder) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1Builder)));
        }

        /// <summary>
        ///  read status of the specified namespace scoped Builder
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>KpackBuildV1alpha1Builder</returns>
        public KpackBuildV1alpha1Builder GetBuilderStatus (string _namespace, string name)
        {
             ApiResponse<KpackBuildV1alpha1Builder> localVarResponse = GetBuilderStatusWithHttpInfo(_namespace, name);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  read status of the specified namespace scoped Builder
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1Builder</returns>
        public ApiResponse<KpackBuildV1alpha1Builder> GetBuilderStatusWithHttpInfo (string _namespace, string name)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling KpackApi->GetBuilderStatus");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->GetBuilderStatus");

            var localVarPath = "/apis/kpack.io/v1alpha1/namespaces/{namespace}/builders/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", this.Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetBuilderStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1Builder>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1Builder) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1Builder)));
        }

        /// <summary>
        ///  read status of the specified namespace scoped Builder
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>Task of KpackBuildV1alpha1Builder</returns>
        public async System.Threading.Tasks.Task<KpackBuildV1alpha1Builder> GetBuilderStatusAsync (string _namespace, string name)
        {
             ApiResponse<KpackBuildV1alpha1Builder> localVarResponse = await GetBuilderStatusAsyncWithHttpInfo(_namespace, name);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  read status of the specified namespace scoped Builder
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1Builder)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1Builder>> GetBuilderStatusAsyncWithHttpInfo (string _namespace, string name)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling KpackApi->GetBuilderStatus");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->GetBuilderStatus");

            var localVarPath = "/apis/kpack.io/v1alpha1/namespaces/{namespace}/builders/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", this.Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetBuilderStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1Builder>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1Builder) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1Builder)));
        }

        /// <summary>
        ///  Returns a cluster scoped ClusterBuilder
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>KpackBuildV1alpha1ClusterBuilder</returns>
        public KpackBuildV1alpha1ClusterBuilder GetClusterBuilder (string name)
        {
             ApiResponse<KpackBuildV1alpha1ClusterBuilder> localVarResponse = GetClusterBuilderWithHttpInfo(name);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  Returns a cluster scoped ClusterBuilder
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1ClusterBuilder</returns>
        public ApiResponse<KpackBuildV1alpha1ClusterBuilder> GetClusterBuilderWithHttpInfo (string name)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->GetClusterBuilder");

            var localVarPath = "/apis/kpack.io/v1alpha1/clusterbuilders/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetClusterBuilder", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1ClusterBuilder>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1ClusterBuilder) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1ClusterBuilder)));
        }

        /// <summary>
        ///  Returns a cluster scoped ClusterBuilder
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>Task of KpackBuildV1alpha1ClusterBuilder</returns>
        public async System.Threading.Tasks.Task<KpackBuildV1alpha1ClusterBuilder> GetClusterBuilderAsync (string name)
        {
             ApiResponse<KpackBuildV1alpha1ClusterBuilder> localVarResponse = await GetClusterBuilderAsyncWithHttpInfo(name);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  Returns a cluster scoped ClusterBuilder
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1ClusterBuilder)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1ClusterBuilder>> GetClusterBuilderAsyncWithHttpInfo (string name)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->GetClusterBuilder");

            var localVarPath = "/apis/kpack.io/v1alpha1/clusterbuilders/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetClusterBuilder", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1ClusterBuilder>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1ClusterBuilder) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1ClusterBuilder)));
        }

        /// <summary>
        ///  read status of the specified cluster scoped ClusterBuilder
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>KpackBuildV1alpha1ClusterBuilder</returns>
        public KpackBuildV1alpha1ClusterBuilder GetClusterBuilderStatus (string name)
        {
             ApiResponse<KpackBuildV1alpha1ClusterBuilder> localVarResponse = GetClusterBuilderStatusWithHttpInfo(name);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  read status of the specified cluster scoped ClusterBuilder
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1ClusterBuilder</returns>
        public ApiResponse<KpackBuildV1alpha1ClusterBuilder> GetClusterBuilderStatusWithHttpInfo (string name)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->GetClusterBuilderStatus");

            var localVarPath = "/apis/kpack.io/v1alpha1/clusterbuilders/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetClusterBuilderStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1ClusterBuilder>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1ClusterBuilder) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1ClusterBuilder)));
        }

        /// <summary>
        ///  read status of the specified cluster scoped ClusterBuilder
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>Task of KpackBuildV1alpha1ClusterBuilder</returns>
        public async System.Threading.Tasks.Task<KpackBuildV1alpha1ClusterBuilder> GetClusterBuilderStatusAsync (string name)
        {
             ApiResponse<KpackBuildV1alpha1ClusterBuilder> localVarResponse = await GetClusterBuilderStatusAsyncWithHttpInfo(name);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  read status of the specified cluster scoped ClusterBuilder
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1ClusterBuilder)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1ClusterBuilder>> GetClusterBuilderStatusAsyncWithHttpInfo (string name)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->GetClusterBuilderStatus");

            var localVarPath = "/apis/kpack.io/v1alpha1/clusterbuilders/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetClusterBuilderStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1ClusterBuilder>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1ClusterBuilder) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1ClusterBuilder)));
        }

        /// <summary>
        ///  Returns a cluster scoped ClusterStack
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>KpackBuildV1alpha1ClusterStack</returns>
        public KpackBuildV1alpha1ClusterStack GetClusterStack (string name)
        {
             ApiResponse<KpackBuildV1alpha1ClusterStack> localVarResponse = GetClusterStackWithHttpInfo(name);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  Returns a cluster scoped ClusterStack
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1ClusterStack</returns>
        public ApiResponse<KpackBuildV1alpha1ClusterStack> GetClusterStackWithHttpInfo (string name)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->GetClusterStack");

            var localVarPath = "/apis/kpack.io/v1alpha1/clusterstacks/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetClusterStack", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1ClusterStack>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1ClusterStack) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1ClusterStack)));
        }

        /// <summary>
        ///  Returns a cluster scoped ClusterStack
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>Task of KpackBuildV1alpha1ClusterStack</returns>
        public async System.Threading.Tasks.Task<KpackBuildV1alpha1ClusterStack> GetClusterStackAsync (string name)
        {
             ApiResponse<KpackBuildV1alpha1ClusterStack> localVarResponse = await GetClusterStackAsyncWithHttpInfo(name);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  Returns a cluster scoped ClusterStack
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1ClusterStack)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1ClusterStack>> GetClusterStackAsyncWithHttpInfo (string name)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->GetClusterStack");

            var localVarPath = "/apis/kpack.io/v1alpha1/clusterstacks/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetClusterStack", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1ClusterStack>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1ClusterStack) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1ClusterStack)));
        }

        /// <summary>
        ///  read status of the specified cluster scoped ClusterStack
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>KpackBuildV1alpha1ClusterStack</returns>
        public KpackBuildV1alpha1ClusterStack GetClusterStackStatus (string name)
        {
             ApiResponse<KpackBuildV1alpha1ClusterStack> localVarResponse = GetClusterStackStatusWithHttpInfo(name);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  read status of the specified cluster scoped ClusterStack
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1ClusterStack</returns>
        public ApiResponse<KpackBuildV1alpha1ClusterStack> GetClusterStackStatusWithHttpInfo (string name)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->GetClusterStackStatus");

            var localVarPath = "/apis/kpack.io/v1alpha1/clusterstacks/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetClusterStackStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1ClusterStack>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1ClusterStack) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1ClusterStack)));
        }

        /// <summary>
        ///  read status of the specified cluster scoped ClusterStack
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>Task of KpackBuildV1alpha1ClusterStack</returns>
        public async System.Threading.Tasks.Task<KpackBuildV1alpha1ClusterStack> GetClusterStackStatusAsync (string name)
        {
             ApiResponse<KpackBuildV1alpha1ClusterStack> localVarResponse = await GetClusterStackStatusAsyncWithHttpInfo(name);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  read status of the specified cluster scoped ClusterStack
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1ClusterStack)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1ClusterStack>> GetClusterStackStatusAsyncWithHttpInfo (string name)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->GetClusterStackStatus");

            var localVarPath = "/apis/kpack.io/v1alpha1/clusterstacks/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetClusterStackStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1ClusterStack>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1ClusterStack) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1ClusterStack)));
        }

        /// <summary>
        ///  Returns a cluster scoped ClusterStore
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>KpackBuildV1alpha1ClusterStore</returns>
        public KpackBuildV1alpha1ClusterStore GetClusterStore (string name)
        {
             ApiResponse<KpackBuildV1alpha1ClusterStore> localVarResponse = GetClusterStoreWithHttpInfo(name);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  Returns a cluster scoped ClusterStore
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1ClusterStore</returns>
        public ApiResponse<KpackBuildV1alpha1ClusterStore> GetClusterStoreWithHttpInfo (string name)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->GetClusterStore");

            var localVarPath = "/apis/kpack.io/v1alpha1/clusterstores/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetClusterStore", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1ClusterStore>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1ClusterStore) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1ClusterStore)));
        }

        /// <summary>
        ///  Returns a cluster scoped ClusterStore
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>Task of KpackBuildV1alpha1ClusterStore</returns>
        public async System.Threading.Tasks.Task<KpackBuildV1alpha1ClusterStore> GetClusterStoreAsync (string name)
        {
             ApiResponse<KpackBuildV1alpha1ClusterStore> localVarResponse = await GetClusterStoreAsyncWithHttpInfo(name);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  Returns a cluster scoped ClusterStore
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1ClusterStore)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1ClusterStore>> GetClusterStoreAsyncWithHttpInfo (string name)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->GetClusterStore");

            var localVarPath = "/apis/kpack.io/v1alpha1/clusterstores/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetClusterStore", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1ClusterStore>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1ClusterStore) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1ClusterStore)));
        }

        /// <summary>
        ///  read status of the specified cluster scoped ClusterStore
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>KpackBuildV1alpha1ClusterStore</returns>
        public KpackBuildV1alpha1ClusterStore GetClusterStoreStatus (string name)
        {
             ApiResponse<KpackBuildV1alpha1ClusterStore> localVarResponse = GetClusterStoreStatusWithHttpInfo(name);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  read status of the specified cluster scoped ClusterStore
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1ClusterStore</returns>
        public ApiResponse<KpackBuildV1alpha1ClusterStore> GetClusterStoreStatusWithHttpInfo (string name)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->GetClusterStoreStatus");

            var localVarPath = "/apis/kpack.io/v1alpha1/clusterstores/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetClusterStoreStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1ClusterStore>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1ClusterStore) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1ClusterStore)));
        }

        /// <summary>
        ///  read status of the specified cluster scoped ClusterStore
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>Task of KpackBuildV1alpha1ClusterStore</returns>
        public async System.Threading.Tasks.Task<KpackBuildV1alpha1ClusterStore> GetClusterStoreStatusAsync (string name)
        {
             ApiResponse<KpackBuildV1alpha1ClusterStore> localVarResponse = await GetClusterStoreStatusAsyncWithHttpInfo(name);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  read status of the specified cluster scoped ClusterStore
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1ClusterStore)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1ClusterStore>> GetClusterStoreStatusAsyncWithHttpInfo (string name)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->GetClusterStoreStatus");

            var localVarPath = "/apis/kpack.io/v1alpha1/clusterstores/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetClusterStoreStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1ClusterStore>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1ClusterStore) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1ClusterStore)));
        }

        /// <summary>
        ///  Returns a namespace scoped custom object
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>KpackBuildV1alpha1Image</returns>
        public KpackBuildV1alpha1Image GetImage (string _namespace, string name)
        {
             ApiResponse<KpackBuildV1alpha1Image> localVarResponse = GetImageWithHttpInfo(_namespace, name);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  Returns a namespace scoped custom object
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1Image</returns>
        public ApiResponse<KpackBuildV1alpha1Image> GetImageWithHttpInfo (string _namespace, string name)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling KpackApi->GetImage");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->GetImage");

            var localVarPath = "/apis/kpack.io/v1alpha1/namespaces/{namespace}/images/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", this.Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetImage", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1Image>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1Image) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1Image)));
        }

        /// <summary>
        ///  Returns a namespace scoped custom object
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>Task of KpackBuildV1alpha1Image</returns>
        public async System.Threading.Tasks.Task<KpackBuildV1alpha1Image> GetImageAsync (string _namespace, string name)
        {
             ApiResponse<KpackBuildV1alpha1Image> localVarResponse = await GetImageAsyncWithHttpInfo(_namespace, name);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  Returns a namespace scoped custom object
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1Image)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1Image>> GetImageAsyncWithHttpInfo (string _namespace, string name)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling KpackApi->GetImage");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->GetImage");

            var localVarPath = "/apis/kpack.io/v1alpha1/namespaces/{namespace}/images/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", this.Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetImage", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1Image>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1Image) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1Image)));
        }

        /// <summary>
        ///  read status of the specified namespace scoped Image
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>KpackBuildV1alpha1Image</returns>
        public KpackBuildV1alpha1Image GetImageStatus (string _namespace, string name)
        {
             ApiResponse<KpackBuildV1alpha1Image> localVarResponse = GetImageStatusWithHttpInfo(_namespace, name);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  read status of the specified namespace scoped Image
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1Image</returns>
        public ApiResponse<KpackBuildV1alpha1Image> GetImageStatusWithHttpInfo (string _namespace, string name)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling KpackApi->GetImageStatus");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->GetImageStatus");

            var localVarPath = "/apis/kpack.io/v1alpha1/namespaces/{namespace}/images/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", this.Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetImageStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1Image>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1Image) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1Image)));
        }

        /// <summary>
        ///  read status of the specified namespace scoped Image
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>Task of KpackBuildV1alpha1Image</returns>
        public async System.Threading.Tasks.Task<KpackBuildV1alpha1Image> GetImageStatusAsync (string _namespace, string name)
        {
             ApiResponse<KpackBuildV1alpha1Image> localVarResponse = await GetImageStatusAsyncWithHttpInfo(_namespace, name);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  read status of the specified namespace scoped Image
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1Image)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1Image>> GetImageStatusAsyncWithHttpInfo (string _namespace, string name)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling KpackApi->GetImageStatus");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->GetImageStatus");

            var localVarPath = "/apis/kpack.io/v1alpha1/namespaces/{namespace}/images/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", this.Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetImageStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1Image>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1Image) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1Image)));
        }

        /// <summary>
        ///  Returns a namespace scoped custom object
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>KpackBuildV1alpha1SourceResolver</returns>
        public KpackBuildV1alpha1SourceResolver GetSourceResolver (string _namespace, string name)
        {
             ApiResponse<KpackBuildV1alpha1SourceResolver> localVarResponse = GetSourceResolverWithHttpInfo(_namespace, name);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  Returns a namespace scoped custom object
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1SourceResolver</returns>
        public ApiResponse<KpackBuildV1alpha1SourceResolver> GetSourceResolverWithHttpInfo (string _namespace, string name)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling KpackApi->GetSourceResolver");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->GetSourceResolver");

            var localVarPath = "/apis/kpack.io/v1alpha1/namespaces/{namespace}/sourceresolvers/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", this.Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSourceResolver", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1SourceResolver>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1SourceResolver) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1SourceResolver)));
        }

        /// <summary>
        ///  Returns a namespace scoped custom object
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>Task of KpackBuildV1alpha1SourceResolver</returns>
        public async System.Threading.Tasks.Task<KpackBuildV1alpha1SourceResolver> GetSourceResolverAsync (string _namespace, string name)
        {
             ApiResponse<KpackBuildV1alpha1SourceResolver> localVarResponse = await GetSourceResolverAsyncWithHttpInfo(_namespace, name);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  Returns a namespace scoped custom object
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1SourceResolver)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1SourceResolver>> GetSourceResolverAsyncWithHttpInfo (string _namespace, string name)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling KpackApi->GetSourceResolver");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->GetSourceResolver");

            var localVarPath = "/apis/kpack.io/v1alpha1/namespaces/{namespace}/sourceresolvers/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", this.Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSourceResolver", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1SourceResolver>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1SourceResolver) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1SourceResolver)));
        }

        /// <summary>
        ///  read status of the specified namespace scoped SourceResolver
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>KpackBuildV1alpha1SourceResolver</returns>
        public KpackBuildV1alpha1SourceResolver GetSourceResolverStatus (string _namespace, string name)
        {
             ApiResponse<KpackBuildV1alpha1SourceResolver> localVarResponse = GetSourceResolverStatusWithHttpInfo(_namespace, name);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  read status of the specified namespace scoped SourceResolver
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1SourceResolver</returns>
        public ApiResponse<KpackBuildV1alpha1SourceResolver> GetSourceResolverStatusWithHttpInfo (string _namespace, string name)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling KpackApi->GetSourceResolverStatus");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->GetSourceResolverStatus");

            var localVarPath = "/apis/kpack.io/v1alpha1/namespaces/{namespace}/sourceresolvers/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", this.Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSourceResolverStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1SourceResolver>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1SourceResolver) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1SourceResolver)));
        }

        /// <summary>
        ///  read status of the specified namespace scoped SourceResolver
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>Task of KpackBuildV1alpha1SourceResolver</returns>
        public async System.Threading.Tasks.Task<KpackBuildV1alpha1SourceResolver> GetSourceResolverStatusAsync (string _namespace, string name)
        {
             ApiResponse<KpackBuildV1alpha1SourceResolver> localVarResponse = await GetSourceResolverStatusAsyncWithHttpInfo(_namespace, name);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  read status of the specified namespace scoped SourceResolver
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1SourceResolver)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1SourceResolver>> GetSourceResolverStatusAsyncWithHttpInfo (string _namespace, string name)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling KpackApi->GetSourceResolverStatus");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->GetSourceResolverStatus");

            var localVarPath = "/apis/kpack.io/v1alpha1/namespaces/{namespace}/sourceresolvers/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", this.Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetSourceResolverStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1SourceResolver>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1SourceResolver) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1SourceResolver)));
        }

        /// <summary>
        ///  list or watch builders
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>KpackBuildV1alpha1BuilderList</returns>
        public KpackBuildV1alpha1BuilderList ListAllBuilders (string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
        {
             ApiResponse<KpackBuildV1alpha1BuilderList> localVarResponse = ListAllBuildersWithHttpInfo(pretty, _continue, fieldSelector, labelSelector, limit, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  list or watch builders
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1BuilderList</returns>
        public ApiResponse<KpackBuildV1alpha1BuilderList> ListAllBuildersWithHttpInfo (string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
        {

            var localVarPath = "/apis/kpack.io/v1alpha1/builders";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/json;stream=watch"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (pretty != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "pretty", pretty)); // query parameter
            if (_continue != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "continue", _continue)); // query parameter
            if (fieldSelector != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "fieldSelector", fieldSelector)); // query parameter
            if (labelSelector != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "labelSelector", labelSelector)); // query parameter
            if (limit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "limit", limit)); // query parameter
            if (resourceVersion != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "resourceVersion", resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "timeoutSeconds", timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "watch", watch)); // query parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListAllBuilders", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1BuilderList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1BuilderList) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1BuilderList)));
        }

        /// <summary>
        ///  list or watch builders
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>Task of KpackBuildV1alpha1BuilderList</returns>
        public async System.Threading.Tasks.Task<KpackBuildV1alpha1BuilderList> ListAllBuildersAsync (string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
        {
             ApiResponse<KpackBuildV1alpha1BuilderList> localVarResponse = await ListAllBuildersAsyncWithHttpInfo(pretty, _continue, fieldSelector, labelSelector, limit, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  list or watch builders
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1BuilderList)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1BuilderList>> ListAllBuildersAsyncWithHttpInfo (string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
        {

            var localVarPath = "/apis/kpack.io/v1alpha1/builders";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/json;stream=watch"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (pretty != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "pretty", pretty)); // query parameter
            if (_continue != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "continue", _continue)); // query parameter
            if (fieldSelector != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "fieldSelector", fieldSelector)); // query parameter
            if (labelSelector != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "labelSelector", labelSelector)); // query parameter
            if (limit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "limit", limit)); // query parameter
            if (resourceVersion != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "resourceVersion", resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "timeoutSeconds", timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "watch", watch)); // query parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListAllBuilders", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1BuilderList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1BuilderList) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1BuilderList)));
        }

        /// <summary>
        ///  list or watch builds
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>KpackBuildV1alpha1BuildList</returns>
        public KpackBuildV1alpha1BuildList ListAllBuilds (string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
        {
             ApiResponse<KpackBuildV1alpha1BuildList> localVarResponse = ListAllBuildsWithHttpInfo(pretty, _continue, fieldSelector, labelSelector, limit, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  list or watch builds
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1BuildList</returns>
        public ApiResponse<KpackBuildV1alpha1BuildList> ListAllBuildsWithHttpInfo (string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
        {

            var localVarPath = "/apis/kpack.io/v1alpha1/builds";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/json;stream=watch"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (pretty != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "pretty", pretty)); // query parameter
            if (_continue != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "continue", _continue)); // query parameter
            if (fieldSelector != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "fieldSelector", fieldSelector)); // query parameter
            if (labelSelector != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "labelSelector", labelSelector)); // query parameter
            if (limit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "limit", limit)); // query parameter
            if (resourceVersion != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "resourceVersion", resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "timeoutSeconds", timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "watch", watch)); // query parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListAllBuilds", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1BuildList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1BuildList) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1BuildList)));
        }

        /// <summary>
        ///  list or watch builds
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>Task of KpackBuildV1alpha1BuildList</returns>
        public async System.Threading.Tasks.Task<KpackBuildV1alpha1BuildList> ListAllBuildsAsync (string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
        {
             ApiResponse<KpackBuildV1alpha1BuildList> localVarResponse = await ListAllBuildsAsyncWithHttpInfo(pretty, _continue, fieldSelector, labelSelector, limit, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  list or watch builds
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1BuildList)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1BuildList>> ListAllBuildsAsyncWithHttpInfo (string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
        {

            var localVarPath = "/apis/kpack.io/v1alpha1/builds";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/json;stream=watch"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (pretty != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "pretty", pretty)); // query parameter
            if (_continue != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "continue", _continue)); // query parameter
            if (fieldSelector != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "fieldSelector", fieldSelector)); // query parameter
            if (labelSelector != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "labelSelector", labelSelector)); // query parameter
            if (limit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "limit", limit)); // query parameter
            if (resourceVersion != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "resourceVersion", resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "timeoutSeconds", timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "watch", watch)); // query parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListAllBuilds", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1BuildList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1BuildList) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1BuildList)));
        }

        /// <summary>
        ///  list or watch cluster scoped clusterbuilders
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>KpackBuildV1alpha1ClusterBuilderList</returns>
        public KpackBuildV1alpha1ClusterBuilderList ListAllClusterbuilders (string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
        {
             ApiResponse<KpackBuildV1alpha1ClusterBuilderList> localVarResponse = ListAllClusterbuildersWithHttpInfo(pretty, _continue, fieldSelector, labelSelector, limit, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  list or watch cluster scoped clusterbuilders
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1ClusterBuilderList</returns>
        public ApiResponse<KpackBuildV1alpha1ClusterBuilderList> ListAllClusterbuildersWithHttpInfo (string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
        {

            var localVarPath = "/apis/kpack.io/v1alpha1/clusterbuilders";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/json;stream=watch"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (pretty != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "pretty", pretty)); // query parameter
            if (_continue != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "continue", _continue)); // query parameter
            if (fieldSelector != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "fieldSelector", fieldSelector)); // query parameter
            if (labelSelector != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "labelSelector", labelSelector)); // query parameter
            if (limit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "limit", limit)); // query parameter
            if (resourceVersion != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "resourceVersion", resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "timeoutSeconds", timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "watch", watch)); // query parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListAllClusterbuilders", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1ClusterBuilderList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1ClusterBuilderList) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1ClusterBuilderList)));
        }

        /// <summary>
        ///  list or watch cluster scoped clusterbuilders
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>Task of KpackBuildV1alpha1ClusterBuilderList</returns>
        public async System.Threading.Tasks.Task<KpackBuildV1alpha1ClusterBuilderList> ListAllClusterbuildersAsync (string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
        {
             ApiResponse<KpackBuildV1alpha1ClusterBuilderList> localVarResponse = await ListAllClusterbuildersAsyncWithHttpInfo(pretty, _continue, fieldSelector, labelSelector, limit, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  list or watch cluster scoped clusterbuilders
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1ClusterBuilderList)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1ClusterBuilderList>> ListAllClusterbuildersAsyncWithHttpInfo (string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
        {

            var localVarPath = "/apis/kpack.io/v1alpha1/clusterbuilders";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/json;stream=watch"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (pretty != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "pretty", pretty)); // query parameter
            if (_continue != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "continue", _continue)); // query parameter
            if (fieldSelector != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "fieldSelector", fieldSelector)); // query parameter
            if (labelSelector != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "labelSelector", labelSelector)); // query parameter
            if (limit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "limit", limit)); // query parameter
            if (resourceVersion != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "resourceVersion", resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "timeoutSeconds", timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "watch", watch)); // query parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListAllClusterbuilders", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1ClusterBuilderList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1ClusterBuilderList) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1ClusterBuilderList)));
        }

        /// <summary>
        ///  list or watch cluster scoped clusterstacks
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>KpackBuildV1alpha1ClusterStackList</returns>
        public KpackBuildV1alpha1ClusterStackList ListAllClusterstacks (string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
        {
             ApiResponse<KpackBuildV1alpha1ClusterStackList> localVarResponse = ListAllClusterstacksWithHttpInfo(pretty, _continue, fieldSelector, labelSelector, limit, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  list or watch cluster scoped clusterstacks
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1ClusterStackList</returns>
        public ApiResponse<KpackBuildV1alpha1ClusterStackList> ListAllClusterstacksWithHttpInfo (string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
        {

            var localVarPath = "/apis/kpack.io/v1alpha1/clusterstacks";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/json;stream=watch"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (pretty != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "pretty", pretty)); // query parameter
            if (_continue != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "continue", _continue)); // query parameter
            if (fieldSelector != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "fieldSelector", fieldSelector)); // query parameter
            if (labelSelector != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "labelSelector", labelSelector)); // query parameter
            if (limit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "limit", limit)); // query parameter
            if (resourceVersion != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "resourceVersion", resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "timeoutSeconds", timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "watch", watch)); // query parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListAllClusterstacks", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1ClusterStackList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1ClusterStackList) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1ClusterStackList)));
        }

        /// <summary>
        ///  list or watch cluster scoped clusterstacks
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>Task of KpackBuildV1alpha1ClusterStackList</returns>
        public async System.Threading.Tasks.Task<KpackBuildV1alpha1ClusterStackList> ListAllClusterstacksAsync (string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
        {
             ApiResponse<KpackBuildV1alpha1ClusterStackList> localVarResponse = await ListAllClusterstacksAsyncWithHttpInfo(pretty, _continue, fieldSelector, labelSelector, limit, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  list or watch cluster scoped clusterstacks
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1ClusterStackList)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1ClusterStackList>> ListAllClusterstacksAsyncWithHttpInfo (string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
        {

            var localVarPath = "/apis/kpack.io/v1alpha1/clusterstacks";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/json;stream=watch"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (pretty != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "pretty", pretty)); // query parameter
            if (_continue != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "continue", _continue)); // query parameter
            if (fieldSelector != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "fieldSelector", fieldSelector)); // query parameter
            if (labelSelector != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "labelSelector", labelSelector)); // query parameter
            if (limit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "limit", limit)); // query parameter
            if (resourceVersion != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "resourceVersion", resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "timeoutSeconds", timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "watch", watch)); // query parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListAllClusterstacks", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1ClusterStackList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1ClusterStackList) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1ClusterStackList)));
        }

        /// <summary>
        ///  list or watch cluster scoped clusterstores
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>KpackBuildV1alpha1ClusterStoreList</returns>
        public KpackBuildV1alpha1ClusterStoreList ListAllClusterstores (string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
        {
             ApiResponse<KpackBuildV1alpha1ClusterStoreList> localVarResponse = ListAllClusterstoresWithHttpInfo(pretty, _continue, fieldSelector, labelSelector, limit, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  list or watch cluster scoped clusterstores
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1ClusterStoreList</returns>
        public ApiResponse<KpackBuildV1alpha1ClusterStoreList> ListAllClusterstoresWithHttpInfo (string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
        {

            var localVarPath = "/apis/kpack.io/v1alpha1/clusterstores";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/json;stream=watch"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (pretty != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "pretty", pretty)); // query parameter
            if (_continue != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "continue", _continue)); // query parameter
            if (fieldSelector != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "fieldSelector", fieldSelector)); // query parameter
            if (labelSelector != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "labelSelector", labelSelector)); // query parameter
            if (limit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "limit", limit)); // query parameter
            if (resourceVersion != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "resourceVersion", resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "timeoutSeconds", timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "watch", watch)); // query parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListAllClusterstores", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1ClusterStoreList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1ClusterStoreList) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1ClusterStoreList)));
        }

        /// <summary>
        ///  list or watch cluster scoped clusterstores
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>Task of KpackBuildV1alpha1ClusterStoreList</returns>
        public async System.Threading.Tasks.Task<KpackBuildV1alpha1ClusterStoreList> ListAllClusterstoresAsync (string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
        {
             ApiResponse<KpackBuildV1alpha1ClusterStoreList> localVarResponse = await ListAllClusterstoresAsyncWithHttpInfo(pretty, _continue, fieldSelector, labelSelector, limit, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  list or watch cluster scoped clusterstores
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1ClusterStoreList)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1ClusterStoreList>> ListAllClusterstoresAsyncWithHttpInfo (string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
        {

            var localVarPath = "/apis/kpack.io/v1alpha1/clusterstores";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/json;stream=watch"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (pretty != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "pretty", pretty)); // query parameter
            if (_continue != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "continue", _continue)); // query parameter
            if (fieldSelector != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "fieldSelector", fieldSelector)); // query parameter
            if (labelSelector != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "labelSelector", labelSelector)); // query parameter
            if (limit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "limit", limit)); // query parameter
            if (resourceVersion != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "resourceVersion", resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "timeoutSeconds", timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "watch", watch)); // query parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListAllClusterstores", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1ClusterStoreList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1ClusterStoreList) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1ClusterStoreList)));
        }

        /// <summary>
        ///  list or watch images
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>KpackBuildV1alpha1ImageList</returns>
        public KpackBuildV1alpha1ImageList ListAllImages (string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
        {
             ApiResponse<KpackBuildV1alpha1ImageList> localVarResponse = ListAllImagesWithHttpInfo(pretty, _continue, fieldSelector, labelSelector, limit, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  list or watch images
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1ImageList</returns>
        public ApiResponse<KpackBuildV1alpha1ImageList> ListAllImagesWithHttpInfo (string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
        {

            var localVarPath = "/apis/kpack.io/v1alpha1/images";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/json;stream=watch"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (pretty != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "pretty", pretty)); // query parameter
            if (_continue != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "continue", _continue)); // query parameter
            if (fieldSelector != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "fieldSelector", fieldSelector)); // query parameter
            if (labelSelector != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "labelSelector", labelSelector)); // query parameter
            if (limit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "limit", limit)); // query parameter
            if (resourceVersion != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "resourceVersion", resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "timeoutSeconds", timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "watch", watch)); // query parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListAllImages", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1ImageList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1ImageList) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1ImageList)));
        }

        /// <summary>
        ///  list or watch images
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>Task of KpackBuildV1alpha1ImageList</returns>
        public async System.Threading.Tasks.Task<KpackBuildV1alpha1ImageList> ListAllImagesAsync (string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
        {
             ApiResponse<KpackBuildV1alpha1ImageList> localVarResponse = await ListAllImagesAsyncWithHttpInfo(pretty, _continue, fieldSelector, labelSelector, limit, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  list or watch images
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1ImageList)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1ImageList>> ListAllImagesAsyncWithHttpInfo (string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
        {

            var localVarPath = "/apis/kpack.io/v1alpha1/images";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/json;stream=watch"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (pretty != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "pretty", pretty)); // query parameter
            if (_continue != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "continue", _continue)); // query parameter
            if (fieldSelector != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "fieldSelector", fieldSelector)); // query parameter
            if (labelSelector != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "labelSelector", labelSelector)); // query parameter
            if (limit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "limit", limit)); // query parameter
            if (resourceVersion != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "resourceVersion", resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "timeoutSeconds", timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "watch", watch)); // query parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListAllImages", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1ImageList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1ImageList) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1ImageList)));
        }

        /// <summary>
        ///  list or watch sourceresolvers
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>KpackBuildV1alpha1SourceResolverList</returns>
        public KpackBuildV1alpha1SourceResolverList ListAllSourceresolvers (string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
        {
             ApiResponse<KpackBuildV1alpha1SourceResolverList> localVarResponse = ListAllSourceresolversWithHttpInfo(pretty, _continue, fieldSelector, labelSelector, limit, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  list or watch sourceresolvers
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1SourceResolverList</returns>
        public ApiResponse<KpackBuildV1alpha1SourceResolverList> ListAllSourceresolversWithHttpInfo (string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
        {

            var localVarPath = "/apis/kpack.io/v1alpha1/sourceresolvers";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/json;stream=watch"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (pretty != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "pretty", pretty)); // query parameter
            if (_continue != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "continue", _continue)); // query parameter
            if (fieldSelector != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "fieldSelector", fieldSelector)); // query parameter
            if (labelSelector != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "labelSelector", labelSelector)); // query parameter
            if (limit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "limit", limit)); // query parameter
            if (resourceVersion != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "resourceVersion", resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "timeoutSeconds", timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "watch", watch)); // query parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListAllSourceresolvers", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1SourceResolverList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1SourceResolverList) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1SourceResolverList)));
        }

        /// <summary>
        ///  list or watch sourceresolvers
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>Task of KpackBuildV1alpha1SourceResolverList</returns>
        public async System.Threading.Tasks.Task<KpackBuildV1alpha1SourceResolverList> ListAllSourceresolversAsync (string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
        {
             ApiResponse<KpackBuildV1alpha1SourceResolverList> localVarResponse = await ListAllSourceresolversAsyncWithHttpInfo(pretty, _continue, fieldSelector, labelSelector, limit, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  list or watch sourceresolvers
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1SourceResolverList)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1SourceResolverList>> ListAllSourceresolversAsyncWithHttpInfo (string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
        {

            var localVarPath = "/apis/kpack.io/v1alpha1/sourceresolvers";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/json;stream=watch"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (pretty != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "pretty", pretty)); // query parameter
            if (_continue != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "continue", _continue)); // query parameter
            if (fieldSelector != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "fieldSelector", fieldSelector)); // query parameter
            if (labelSelector != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "labelSelector", labelSelector)); // query parameter
            if (limit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "limit", limit)); // query parameter
            if (resourceVersion != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "resourceVersion", resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "timeoutSeconds", timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "watch", watch)); // query parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListAllSourceresolvers", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1SourceResolverList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1SourceResolverList) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1SourceResolverList)));
        }

        /// <summary>
        ///  list or watch namespace scoped builders
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>KpackBuildV1alpha1BuilderList</returns>
        public KpackBuildV1alpha1BuilderList ListNamespacedBuilders (string _namespace, string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
        {
             ApiResponse<KpackBuildV1alpha1BuilderList> localVarResponse = ListNamespacedBuildersWithHttpInfo(_namespace, pretty, _continue, fieldSelector, labelSelector, limit, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  list or watch namespace scoped builders
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1BuilderList</returns>
        public ApiResponse<KpackBuildV1alpha1BuilderList> ListNamespacedBuildersWithHttpInfo (string _namespace, string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling KpackApi->ListNamespacedBuilders");

            var localVarPath = "/apis/kpack.io/v1alpha1/namespaces/{namespace}/builders";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/json;stream=watch"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", this.Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "pretty", pretty)); // query parameter
            if (_continue != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "continue", _continue)); // query parameter
            if (fieldSelector != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "fieldSelector", fieldSelector)); // query parameter
            if (labelSelector != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "labelSelector", labelSelector)); // query parameter
            if (limit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "limit", limit)); // query parameter
            if (resourceVersion != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "resourceVersion", resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "timeoutSeconds", timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "watch", watch)); // query parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListNamespacedBuilders", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1BuilderList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1BuilderList) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1BuilderList)));
        }

        /// <summary>
        ///  list or watch namespace scoped builders
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>Task of KpackBuildV1alpha1BuilderList</returns>
        public async System.Threading.Tasks.Task<KpackBuildV1alpha1BuilderList> ListNamespacedBuildersAsync (string _namespace, string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
        {
             ApiResponse<KpackBuildV1alpha1BuilderList> localVarResponse = await ListNamespacedBuildersAsyncWithHttpInfo(_namespace, pretty, _continue, fieldSelector, labelSelector, limit, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  list or watch namespace scoped builders
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1BuilderList)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1BuilderList>> ListNamespacedBuildersAsyncWithHttpInfo (string _namespace, string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling KpackApi->ListNamespacedBuilders");

            var localVarPath = "/apis/kpack.io/v1alpha1/namespaces/{namespace}/builders";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/json;stream=watch"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", this.Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "pretty", pretty)); // query parameter
            if (_continue != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "continue", _continue)); // query parameter
            if (fieldSelector != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "fieldSelector", fieldSelector)); // query parameter
            if (labelSelector != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "labelSelector", labelSelector)); // query parameter
            if (limit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "limit", limit)); // query parameter
            if (resourceVersion != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "resourceVersion", resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "timeoutSeconds", timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "watch", watch)); // query parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListNamespacedBuilders", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1BuilderList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1BuilderList) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1BuilderList)));
        }

        /// <summary>
        ///  list or watch namespace scoped builds
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>KpackBuildV1alpha1BuildList</returns>
        public KpackBuildV1alpha1BuildList ListNamespacedBuilds (string _namespace, string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
        {
             ApiResponse<KpackBuildV1alpha1BuildList> localVarResponse = ListNamespacedBuildsWithHttpInfo(_namespace, pretty, _continue, fieldSelector, labelSelector, limit, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  list or watch namespace scoped builds
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1BuildList</returns>
        public ApiResponse<KpackBuildV1alpha1BuildList> ListNamespacedBuildsWithHttpInfo (string _namespace, string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling KpackApi->ListNamespacedBuilds");

            var localVarPath = "/apis/kpack.io/v1alpha1/namespaces/{namespace}/builds";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/json;stream=watch"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", this.Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "pretty", pretty)); // query parameter
            if (_continue != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "continue", _continue)); // query parameter
            if (fieldSelector != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "fieldSelector", fieldSelector)); // query parameter
            if (labelSelector != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "labelSelector", labelSelector)); // query parameter
            if (limit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "limit", limit)); // query parameter
            if (resourceVersion != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "resourceVersion", resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "timeoutSeconds", timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "watch", watch)); // query parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListNamespacedBuilds", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1BuildList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1BuildList) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1BuildList)));
        }

        /// <summary>
        ///  list or watch namespace scoped builds
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>Task of KpackBuildV1alpha1BuildList</returns>
        public async System.Threading.Tasks.Task<KpackBuildV1alpha1BuildList> ListNamespacedBuildsAsync (string _namespace, string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
        {
             ApiResponse<KpackBuildV1alpha1BuildList> localVarResponse = await ListNamespacedBuildsAsyncWithHttpInfo(_namespace, pretty, _continue, fieldSelector, labelSelector, limit, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  list or watch namespace scoped builds
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1BuildList)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1BuildList>> ListNamespacedBuildsAsyncWithHttpInfo (string _namespace, string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling KpackApi->ListNamespacedBuilds");

            var localVarPath = "/apis/kpack.io/v1alpha1/namespaces/{namespace}/builds";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/json;stream=watch"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", this.Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "pretty", pretty)); // query parameter
            if (_continue != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "continue", _continue)); // query parameter
            if (fieldSelector != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "fieldSelector", fieldSelector)); // query parameter
            if (labelSelector != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "labelSelector", labelSelector)); // query parameter
            if (limit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "limit", limit)); // query parameter
            if (resourceVersion != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "resourceVersion", resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "timeoutSeconds", timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "watch", watch)); // query parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListNamespacedBuilds", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1BuildList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1BuildList) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1BuildList)));
        }

        /// <summary>
        ///  list or watch namespace scoped images
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>KpackBuildV1alpha1ImageList</returns>
        public KpackBuildV1alpha1ImageList ListNamespacedImages (string _namespace, string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
        {
             ApiResponse<KpackBuildV1alpha1ImageList> localVarResponse = ListNamespacedImagesWithHttpInfo(_namespace, pretty, _continue, fieldSelector, labelSelector, limit, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  list or watch namespace scoped images
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1ImageList</returns>
        public ApiResponse<KpackBuildV1alpha1ImageList> ListNamespacedImagesWithHttpInfo (string _namespace, string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling KpackApi->ListNamespacedImages");

            var localVarPath = "/apis/kpack.io/v1alpha1/namespaces/{namespace}/images";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/json;stream=watch"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", this.Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "pretty", pretty)); // query parameter
            if (_continue != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "continue", _continue)); // query parameter
            if (fieldSelector != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "fieldSelector", fieldSelector)); // query parameter
            if (labelSelector != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "labelSelector", labelSelector)); // query parameter
            if (limit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "limit", limit)); // query parameter
            if (resourceVersion != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "resourceVersion", resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "timeoutSeconds", timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "watch", watch)); // query parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListNamespacedImages", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1ImageList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1ImageList) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1ImageList)));
        }

        /// <summary>
        ///  list or watch namespace scoped images
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>Task of KpackBuildV1alpha1ImageList</returns>
        public async System.Threading.Tasks.Task<KpackBuildV1alpha1ImageList> ListNamespacedImagesAsync (string _namespace, string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
        {
             ApiResponse<KpackBuildV1alpha1ImageList> localVarResponse = await ListNamespacedImagesAsyncWithHttpInfo(_namespace, pretty, _continue, fieldSelector, labelSelector, limit, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  list or watch namespace scoped images
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1ImageList)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1ImageList>> ListNamespacedImagesAsyncWithHttpInfo (string _namespace, string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling KpackApi->ListNamespacedImages");

            var localVarPath = "/apis/kpack.io/v1alpha1/namespaces/{namespace}/images";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/json;stream=watch"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", this.Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "pretty", pretty)); // query parameter
            if (_continue != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "continue", _continue)); // query parameter
            if (fieldSelector != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "fieldSelector", fieldSelector)); // query parameter
            if (labelSelector != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "labelSelector", labelSelector)); // query parameter
            if (limit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "limit", limit)); // query parameter
            if (resourceVersion != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "resourceVersion", resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "timeoutSeconds", timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "watch", watch)); // query parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListNamespacedImages", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1ImageList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1ImageList) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1ImageList)));
        }

        /// <summary>
        ///  list or watch namespace scoped sourceresolvers
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>KpackBuildV1alpha1SourceResolverList</returns>
        public KpackBuildV1alpha1SourceResolverList ListNamespacedSourceresolvers (string _namespace, string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
        {
             ApiResponse<KpackBuildV1alpha1SourceResolverList> localVarResponse = ListNamespacedSourceresolversWithHttpInfo(_namespace, pretty, _continue, fieldSelector, labelSelector, limit, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  list or watch namespace scoped sourceresolvers
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1SourceResolverList</returns>
        public ApiResponse<KpackBuildV1alpha1SourceResolverList> ListNamespacedSourceresolversWithHttpInfo (string _namespace, string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling KpackApi->ListNamespacedSourceresolvers");

            var localVarPath = "/apis/kpack.io/v1alpha1/namespaces/{namespace}/sourceresolvers";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/json;stream=watch"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", this.Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "pretty", pretty)); // query parameter
            if (_continue != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "continue", _continue)); // query parameter
            if (fieldSelector != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "fieldSelector", fieldSelector)); // query parameter
            if (labelSelector != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "labelSelector", labelSelector)); // query parameter
            if (limit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "limit", limit)); // query parameter
            if (resourceVersion != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "resourceVersion", resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "timeoutSeconds", timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "watch", watch)); // query parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListNamespacedSourceresolvers", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1SourceResolverList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1SourceResolverList) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1SourceResolverList)));
        }

        /// <summary>
        ///  list or watch namespace scoped sourceresolvers
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>Task of KpackBuildV1alpha1SourceResolverList</returns>
        public async System.Threading.Tasks.Task<KpackBuildV1alpha1SourceResolverList> ListNamespacedSourceresolversAsync (string _namespace, string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
        {
             ApiResponse<KpackBuildV1alpha1SourceResolverList> localVarResponse = await ListNamespacedSourceresolversAsyncWithHttpInfo(_namespace, pretty, _continue, fieldSelector, labelSelector, limit, resourceVersion, timeoutSeconds, watch);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  list or watch namespace scoped sourceresolvers
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="pretty">If &#39;true&#39;, then the output is pretty printed. (optional)</param>
        /// <param name="_continue">The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications. (optional)</param>
        /// <param name="fieldSelector">A selector to restrict the list of returned objects by their fields. Defaults to everything. (optional)</param>
        /// <param name="labelSelector">A selector to restrict the list of returned objects by their labels. Defaults to everything. (optional)</param>
        /// <param name="limit">limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#39;continue&#39; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned. (optional)</param>
        /// <param name="resourceVersion">When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv. (optional)</param>
        /// <param name="timeoutSeconds">Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity. (optional)</param>
        /// <param name="watch">Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. (optional)</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1SourceResolverList)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1SourceResolverList>> ListNamespacedSourceresolversAsyncWithHttpInfo (string _namespace, string pretty = default(string), string _continue = default(string), string fieldSelector = default(string), string labelSelector = default(string), int? limit = default(int?), string resourceVersion = default(string), int? timeoutSeconds = default(int?), bool? watch = default(bool?))
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling KpackApi->ListNamespacedSourceresolvers");

            var localVarPath = "/apis/kpack.io/v1alpha1/namespaces/{namespace}/sourceresolvers";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/json;stream=watch"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", this.Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (pretty != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "pretty", pretty)); // query parameter
            if (_continue != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "continue", _continue)); // query parameter
            if (fieldSelector != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "fieldSelector", fieldSelector)); // query parameter
            if (labelSelector != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "labelSelector", labelSelector)); // query parameter
            if (limit != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "limit", limit)); // query parameter
            if (resourceVersion != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "resourceVersion", resourceVersion)); // query parameter
            if (timeoutSeconds != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "timeoutSeconds", timeoutSeconds)); // query parameter
            if (watch != null) localVarQueryParams.AddRange(this.Configuration.ApiClient.ParameterToKeyValuePairs("", "watch", watch)); // query parameter


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ListNamespacedSourceresolvers", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1SourceResolverList>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1SourceResolverList) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1SourceResolverList)));
        }

        /// <summary>
        ///  patch the specified namespace scoped Build
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to patch.</param>
        /// <returns>KpackBuildV1alpha1Build</returns>
        public KpackBuildV1alpha1Build PatchBuild (string _namespace, string name, Object body)
        {
             ApiResponse<KpackBuildV1alpha1Build> localVarResponse = PatchBuildWithHttpInfo(_namespace, name, body);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  patch the specified namespace scoped Build
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to patch.</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1Build</returns>
        public ApiResponse<KpackBuildV1alpha1Build> PatchBuildWithHttpInfo (string _namespace, string name, Object body)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling KpackApi->PatchBuild");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->PatchBuild");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling KpackApi->PatchBuild");

            var localVarPath = "/apis/kpack.io/v1alpha1/namespaces/{namespace}/builds/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", this.Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchBuild", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1Build>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1Build) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1Build)));
        }

        /// <summary>
        ///  patch the specified namespace scoped Build
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to patch.</param>
        /// <returns>Task of KpackBuildV1alpha1Build</returns>
        public async System.Threading.Tasks.Task<KpackBuildV1alpha1Build> PatchBuildAsync (string _namespace, string name, Object body)
        {
             ApiResponse<KpackBuildV1alpha1Build> localVarResponse = await PatchBuildAsyncWithHttpInfo(_namespace, name, body);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  patch the specified namespace scoped Build
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to patch.</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1Build)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1Build>> PatchBuildAsyncWithHttpInfo (string _namespace, string name, Object body)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling KpackApi->PatchBuild");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->PatchBuild");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling KpackApi->PatchBuild");

            var localVarPath = "/apis/kpack.io/v1alpha1/namespaces/{namespace}/builds/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", this.Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchBuild", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1Build>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1Build) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1Build)));
        }

        /// <summary>
        ///  partially update status of the specified namespace scoped Build
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>KpackBuildV1alpha1Build</returns>
        public KpackBuildV1alpha1Build PatchBuildStatus (string _namespace, string name, Object body)
        {
             ApiResponse<KpackBuildV1alpha1Build> localVarResponse = PatchBuildStatusWithHttpInfo(_namespace, name, body);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  partially update status of the specified namespace scoped Build
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>ApiResponse of KpackBuildV1alpha1Build</returns>
        public ApiResponse<KpackBuildV1alpha1Build> PatchBuildStatusWithHttpInfo (string _namespace, string name, Object body)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling KpackApi->PatchBuildStatus");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->PatchBuildStatus");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling KpackApi->PatchBuildStatus");

            var localVarPath = "/apis/kpack.io/v1alpha1/namespaces/{namespace}/builds/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", this.Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchBuildStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1Build>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1Build) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1Build)));
        }

        /// <summary>
        ///  partially update status of the specified namespace scoped Build
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>Task of KpackBuildV1alpha1Build</returns>
        public async System.Threading.Tasks.Task<KpackBuildV1alpha1Build> PatchBuildStatusAsync (string _namespace, string name, Object body)
        {
             ApiResponse<KpackBuildV1alpha1Build> localVarResponse = await PatchBuildStatusAsyncWithHttpInfo(_namespace, name, body);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  partially update status of the specified namespace scoped Build
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1Build)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1Build>> PatchBuildStatusAsyncWithHttpInfo (string _namespace, string name, Object body)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling KpackApi->PatchBuildStatus");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->PatchBuildStatus");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling KpackApi->PatchBuildStatus");

            var localVarPath = "/apis/kpack.io/v1alpha1/namespaces/{namespace}/builds/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", this.Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchBuildStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1Build>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1Build) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1Build)));
        }

        /// <summary>
        ///  patch the specified namespace scoped Builder
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to patch.</param>
        /// <returns>KpackBuildV1alpha1Builder</returns>
        public KpackBuildV1alpha1Builder PatchBuilder (string _namespace, string name, Object body)
        {
             ApiResponse<KpackBuildV1alpha1Builder> localVarResponse = PatchBuilderWithHttpInfo(_namespace, name, body);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  patch the specified namespace scoped Builder
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to patch.</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1Builder</returns>
        public ApiResponse<KpackBuildV1alpha1Builder> PatchBuilderWithHttpInfo (string _namespace, string name, Object body)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling KpackApi->PatchBuilder");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->PatchBuilder");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling KpackApi->PatchBuilder");

            var localVarPath = "/apis/kpack.io/v1alpha1/namespaces/{namespace}/builders/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", this.Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchBuilder", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1Builder>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1Builder) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1Builder)));
        }

        /// <summary>
        ///  patch the specified namespace scoped Builder
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to patch.</param>
        /// <returns>Task of KpackBuildV1alpha1Builder</returns>
        public async System.Threading.Tasks.Task<KpackBuildV1alpha1Builder> PatchBuilderAsync (string _namespace, string name, Object body)
        {
             ApiResponse<KpackBuildV1alpha1Builder> localVarResponse = await PatchBuilderAsyncWithHttpInfo(_namespace, name, body);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  patch the specified namespace scoped Builder
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to patch.</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1Builder)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1Builder>> PatchBuilderAsyncWithHttpInfo (string _namespace, string name, Object body)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling KpackApi->PatchBuilder");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->PatchBuilder");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling KpackApi->PatchBuilder");

            var localVarPath = "/apis/kpack.io/v1alpha1/namespaces/{namespace}/builders/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", this.Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchBuilder", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1Builder>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1Builder) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1Builder)));
        }

        /// <summary>
        ///  partially update status of the specified namespace scoped Builder
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>KpackBuildV1alpha1Builder</returns>
        public KpackBuildV1alpha1Builder PatchBuilderStatus (string _namespace, string name, Object body)
        {
             ApiResponse<KpackBuildV1alpha1Builder> localVarResponse = PatchBuilderStatusWithHttpInfo(_namespace, name, body);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  partially update status of the specified namespace scoped Builder
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>ApiResponse of KpackBuildV1alpha1Builder</returns>
        public ApiResponse<KpackBuildV1alpha1Builder> PatchBuilderStatusWithHttpInfo (string _namespace, string name, Object body)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling KpackApi->PatchBuilderStatus");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->PatchBuilderStatus");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling KpackApi->PatchBuilderStatus");

            var localVarPath = "/apis/kpack.io/v1alpha1/namespaces/{namespace}/builders/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", this.Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchBuilderStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1Builder>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1Builder) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1Builder)));
        }

        /// <summary>
        ///  partially update status of the specified namespace scoped Builder
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>Task of KpackBuildV1alpha1Builder</returns>
        public async System.Threading.Tasks.Task<KpackBuildV1alpha1Builder> PatchBuilderStatusAsync (string _namespace, string name, Object body)
        {
             ApiResponse<KpackBuildV1alpha1Builder> localVarResponse = await PatchBuilderStatusAsyncWithHttpInfo(_namespace, name, body);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  partially update status of the specified namespace scoped Builder
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1Builder)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1Builder>> PatchBuilderStatusAsyncWithHttpInfo (string _namespace, string name, Object body)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling KpackApi->PatchBuilderStatus");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->PatchBuilderStatus");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling KpackApi->PatchBuilderStatus");

            var localVarPath = "/apis/kpack.io/v1alpha1/namespaces/{namespace}/builders/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", this.Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchBuilderStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1Builder>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1Builder) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1Builder)));
        }

        /// <summary>
        ///  patch the specified cluster scoped ClusterBuilder
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to patch.</param>
        /// <returns>KpackBuildV1alpha1ClusterBuilder</returns>
        public KpackBuildV1alpha1ClusterBuilder PatchClusterBuilder (string name, Object body)
        {
             ApiResponse<KpackBuildV1alpha1ClusterBuilder> localVarResponse = PatchClusterBuilderWithHttpInfo(name, body);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  patch the specified cluster scoped ClusterBuilder
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to patch.</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1ClusterBuilder</returns>
        public ApiResponse<KpackBuildV1alpha1ClusterBuilder> PatchClusterBuilderWithHttpInfo (string name, Object body)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->PatchClusterBuilder");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling KpackApi->PatchClusterBuilder");

            var localVarPath = "/apis/kpack.io/v1alpha1/clusterbuilders/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchClusterBuilder", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1ClusterBuilder>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1ClusterBuilder) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1ClusterBuilder)));
        }

        /// <summary>
        ///  patch the specified cluster scoped ClusterBuilder
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to patch.</param>
        /// <returns>Task of KpackBuildV1alpha1ClusterBuilder</returns>
        public async System.Threading.Tasks.Task<KpackBuildV1alpha1ClusterBuilder> PatchClusterBuilderAsync (string name, Object body)
        {
             ApiResponse<KpackBuildV1alpha1ClusterBuilder> localVarResponse = await PatchClusterBuilderAsyncWithHttpInfo(name, body);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  patch the specified cluster scoped ClusterBuilder
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to patch.</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1ClusterBuilder)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1ClusterBuilder>> PatchClusterBuilderAsyncWithHttpInfo (string name, Object body)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->PatchClusterBuilder");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling KpackApi->PatchClusterBuilder");

            var localVarPath = "/apis/kpack.io/v1alpha1/clusterbuilders/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchClusterBuilder", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1ClusterBuilder>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1ClusterBuilder) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1ClusterBuilder)));
        }

        /// <summary>
        ///  partially update status of the specified cluster scoped ClusterBuilder
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>KpackBuildV1alpha1ClusterBuilder</returns>
        public KpackBuildV1alpha1ClusterBuilder PatchClusterBuilderStatus (string name, Object body)
        {
             ApiResponse<KpackBuildV1alpha1ClusterBuilder> localVarResponse = PatchClusterBuilderStatusWithHttpInfo(name, body);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  partially update status of the specified cluster scoped ClusterBuilder
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>ApiResponse of KpackBuildV1alpha1ClusterBuilder</returns>
        public ApiResponse<KpackBuildV1alpha1ClusterBuilder> PatchClusterBuilderStatusWithHttpInfo (string name, Object body)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->PatchClusterBuilderStatus");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling KpackApi->PatchClusterBuilderStatus");

            var localVarPath = "/apis/kpack.io/v1alpha1/clusterbuilders/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchClusterBuilderStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1ClusterBuilder>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1ClusterBuilder) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1ClusterBuilder)));
        }

        /// <summary>
        ///  partially update status of the specified cluster scoped ClusterBuilder
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>Task of KpackBuildV1alpha1ClusterBuilder</returns>
        public async System.Threading.Tasks.Task<KpackBuildV1alpha1ClusterBuilder> PatchClusterBuilderStatusAsync (string name, Object body)
        {
             ApiResponse<KpackBuildV1alpha1ClusterBuilder> localVarResponse = await PatchClusterBuilderStatusAsyncWithHttpInfo(name, body);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  partially update status of the specified cluster scoped ClusterBuilder
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1ClusterBuilder)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1ClusterBuilder>> PatchClusterBuilderStatusAsyncWithHttpInfo (string name, Object body)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->PatchClusterBuilderStatus");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling KpackApi->PatchClusterBuilderStatus");

            var localVarPath = "/apis/kpack.io/v1alpha1/clusterbuilders/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchClusterBuilderStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1ClusterBuilder>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1ClusterBuilder) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1ClusterBuilder)));
        }

        /// <summary>
        ///  patch the specified cluster scoped ClusterStack
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to patch.</param>
        /// <returns>KpackBuildV1alpha1ClusterStack</returns>
        public KpackBuildV1alpha1ClusterStack PatchClusterStack (string name, Object body)
        {
             ApiResponse<KpackBuildV1alpha1ClusterStack> localVarResponse = PatchClusterStackWithHttpInfo(name, body);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  patch the specified cluster scoped ClusterStack
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to patch.</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1ClusterStack</returns>
        public ApiResponse<KpackBuildV1alpha1ClusterStack> PatchClusterStackWithHttpInfo (string name, Object body)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->PatchClusterStack");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling KpackApi->PatchClusterStack");

            var localVarPath = "/apis/kpack.io/v1alpha1/clusterstacks/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchClusterStack", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1ClusterStack>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1ClusterStack) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1ClusterStack)));
        }

        /// <summary>
        ///  patch the specified cluster scoped ClusterStack
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to patch.</param>
        /// <returns>Task of KpackBuildV1alpha1ClusterStack</returns>
        public async System.Threading.Tasks.Task<KpackBuildV1alpha1ClusterStack> PatchClusterStackAsync (string name, Object body)
        {
             ApiResponse<KpackBuildV1alpha1ClusterStack> localVarResponse = await PatchClusterStackAsyncWithHttpInfo(name, body);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  patch the specified cluster scoped ClusterStack
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to patch.</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1ClusterStack)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1ClusterStack>> PatchClusterStackAsyncWithHttpInfo (string name, Object body)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->PatchClusterStack");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling KpackApi->PatchClusterStack");

            var localVarPath = "/apis/kpack.io/v1alpha1/clusterstacks/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchClusterStack", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1ClusterStack>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1ClusterStack) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1ClusterStack)));
        }

        /// <summary>
        ///  partially update status of the specified cluster scoped ClusterStack
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>KpackBuildV1alpha1ClusterStack</returns>
        public KpackBuildV1alpha1ClusterStack PatchClusterStackStatus (string name, Object body)
        {
             ApiResponse<KpackBuildV1alpha1ClusterStack> localVarResponse = PatchClusterStackStatusWithHttpInfo(name, body);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  partially update status of the specified cluster scoped ClusterStack
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>ApiResponse of KpackBuildV1alpha1ClusterStack</returns>
        public ApiResponse<KpackBuildV1alpha1ClusterStack> PatchClusterStackStatusWithHttpInfo (string name, Object body)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->PatchClusterStackStatus");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling KpackApi->PatchClusterStackStatus");

            var localVarPath = "/apis/kpack.io/v1alpha1/clusterstacks/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchClusterStackStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1ClusterStack>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1ClusterStack) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1ClusterStack)));
        }

        /// <summary>
        ///  partially update status of the specified cluster scoped ClusterStack
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>Task of KpackBuildV1alpha1ClusterStack</returns>
        public async System.Threading.Tasks.Task<KpackBuildV1alpha1ClusterStack> PatchClusterStackStatusAsync (string name, Object body)
        {
             ApiResponse<KpackBuildV1alpha1ClusterStack> localVarResponse = await PatchClusterStackStatusAsyncWithHttpInfo(name, body);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  partially update status of the specified cluster scoped ClusterStack
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1ClusterStack)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1ClusterStack>> PatchClusterStackStatusAsyncWithHttpInfo (string name, Object body)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->PatchClusterStackStatus");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling KpackApi->PatchClusterStackStatus");

            var localVarPath = "/apis/kpack.io/v1alpha1/clusterstacks/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchClusterStackStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1ClusterStack>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1ClusterStack) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1ClusterStack)));
        }

        /// <summary>
        ///  patch the specified cluster scoped ClusterStore
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to patch.</param>
        /// <returns>KpackBuildV1alpha1ClusterStore</returns>
        public KpackBuildV1alpha1ClusterStore PatchClusterStore (string name, Object body)
        {
             ApiResponse<KpackBuildV1alpha1ClusterStore> localVarResponse = PatchClusterStoreWithHttpInfo(name, body);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  patch the specified cluster scoped ClusterStore
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to patch.</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1ClusterStore</returns>
        public ApiResponse<KpackBuildV1alpha1ClusterStore> PatchClusterStoreWithHttpInfo (string name, Object body)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->PatchClusterStore");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling KpackApi->PatchClusterStore");

            var localVarPath = "/apis/kpack.io/v1alpha1/clusterstores/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchClusterStore", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1ClusterStore>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1ClusterStore) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1ClusterStore)));
        }

        /// <summary>
        ///  patch the specified cluster scoped ClusterStore
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to patch.</param>
        /// <returns>Task of KpackBuildV1alpha1ClusterStore</returns>
        public async System.Threading.Tasks.Task<KpackBuildV1alpha1ClusterStore> PatchClusterStoreAsync (string name, Object body)
        {
             ApiResponse<KpackBuildV1alpha1ClusterStore> localVarResponse = await PatchClusterStoreAsyncWithHttpInfo(name, body);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  patch the specified cluster scoped ClusterStore
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to patch.</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1ClusterStore)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1ClusterStore>> PatchClusterStoreAsyncWithHttpInfo (string name, Object body)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->PatchClusterStore");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling KpackApi->PatchClusterStore");

            var localVarPath = "/apis/kpack.io/v1alpha1/clusterstores/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchClusterStore", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1ClusterStore>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1ClusterStore) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1ClusterStore)));
        }

        /// <summary>
        ///  partially update status of the specified cluster scoped ClusterStore
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>KpackBuildV1alpha1ClusterStore</returns>
        public KpackBuildV1alpha1ClusterStore PatchClusterStoreStatus (string name, Object body)
        {
             ApiResponse<KpackBuildV1alpha1ClusterStore> localVarResponse = PatchClusterStoreStatusWithHttpInfo(name, body);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  partially update status of the specified cluster scoped ClusterStore
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>ApiResponse of KpackBuildV1alpha1ClusterStore</returns>
        public ApiResponse<KpackBuildV1alpha1ClusterStore> PatchClusterStoreStatusWithHttpInfo (string name, Object body)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->PatchClusterStoreStatus");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling KpackApi->PatchClusterStoreStatus");

            var localVarPath = "/apis/kpack.io/v1alpha1/clusterstores/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchClusterStoreStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1ClusterStore>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1ClusterStore) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1ClusterStore)));
        }

        /// <summary>
        ///  partially update status of the specified cluster scoped ClusterStore
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>Task of KpackBuildV1alpha1ClusterStore</returns>
        public async System.Threading.Tasks.Task<KpackBuildV1alpha1ClusterStore> PatchClusterStoreStatusAsync (string name, Object body)
        {
             ApiResponse<KpackBuildV1alpha1ClusterStore> localVarResponse = await PatchClusterStoreStatusAsyncWithHttpInfo(name, body);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  partially update status of the specified cluster scoped ClusterStore
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1ClusterStore)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1ClusterStore>> PatchClusterStoreStatusAsyncWithHttpInfo (string name, Object body)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->PatchClusterStoreStatus");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling KpackApi->PatchClusterStoreStatus");

            var localVarPath = "/apis/kpack.io/v1alpha1/clusterstores/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchClusterStoreStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1ClusterStore>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1ClusterStore) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1ClusterStore)));
        }

        /// <summary>
        ///  patch the specified namespace scoped Image
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to patch.</param>
        /// <returns>KpackBuildV1alpha1Image</returns>
        public KpackBuildV1alpha1Image PatchImage (string _namespace, string name, Object body)
        {
             ApiResponse<KpackBuildV1alpha1Image> localVarResponse = PatchImageWithHttpInfo(_namespace, name, body);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  patch the specified namespace scoped Image
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to patch.</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1Image</returns>
        public ApiResponse<KpackBuildV1alpha1Image> PatchImageWithHttpInfo (string _namespace, string name, Object body)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling KpackApi->PatchImage");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->PatchImage");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling KpackApi->PatchImage");

            var localVarPath = "/apis/kpack.io/v1alpha1/namespaces/{namespace}/images/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", this.Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchImage", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1Image>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1Image) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1Image)));
        }

        /// <summary>
        ///  patch the specified namespace scoped Image
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to patch.</param>
        /// <returns>Task of KpackBuildV1alpha1Image</returns>
        public async System.Threading.Tasks.Task<KpackBuildV1alpha1Image> PatchImageAsync (string _namespace, string name, Object body)
        {
             ApiResponse<KpackBuildV1alpha1Image> localVarResponse = await PatchImageAsyncWithHttpInfo(_namespace, name, body);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  patch the specified namespace scoped Image
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to patch.</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1Image)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1Image>> PatchImageAsyncWithHttpInfo (string _namespace, string name, Object body)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling KpackApi->PatchImage");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->PatchImage");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling KpackApi->PatchImage");

            var localVarPath = "/apis/kpack.io/v1alpha1/namespaces/{namespace}/images/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", this.Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchImage", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1Image>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1Image) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1Image)));
        }

        /// <summary>
        ///  partially update status of the specified namespace scoped Image
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>KpackBuildV1alpha1Image</returns>
        public KpackBuildV1alpha1Image PatchImageStatus (string _namespace, string name, Object body)
        {
             ApiResponse<KpackBuildV1alpha1Image> localVarResponse = PatchImageStatusWithHttpInfo(_namespace, name, body);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  partially update status of the specified namespace scoped Image
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>ApiResponse of KpackBuildV1alpha1Image</returns>
        public ApiResponse<KpackBuildV1alpha1Image> PatchImageStatusWithHttpInfo (string _namespace, string name, Object body)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling KpackApi->PatchImageStatus");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->PatchImageStatus");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling KpackApi->PatchImageStatus");

            var localVarPath = "/apis/kpack.io/v1alpha1/namespaces/{namespace}/images/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", this.Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchImageStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1Image>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1Image) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1Image)));
        }

        /// <summary>
        ///  partially update status of the specified namespace scoped Image
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>Task of KpackBuildV1alpha1Image</returns>
        public async System.Threading.Tasks.Task<KpackBuildV1alpha1Image> PatchImageStatusAsync (string _namespace, string name, Object body)
        {
             ApiResponse<KpackBuildV1alpha1Image> localVarResponse = await PatchImageStatusAsyncWithHttpInfo(_namespace, name, body);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  partially update status of the specified namespace scoped Image
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1Image)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1Image>> PatchImageStatusAsyncWithHttpInfo (string _namespace, string name, Object body)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling KpackApi->PatchImageStatus");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->PatchImageStatus");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling KpackApi->PatchImageStatus");

            var localVarPath = "/apis/kpack.io/v1alpha1/namespaces/{namespace}/images/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", this.Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchImageStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1Image>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1Image) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1Image)));
        }

        /// <summary>
        ///  patch the specified namespace scoped SourceResolver
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to patch.</param>
        /// <returns>KpackBuildV1alpha1SourceResolver</returns>
        public KpackBuildV1alpha1SourceResolver PatchSourceResolver (string _namespace, string name, Object body)
        {
             ApiResponse<KpackBuildV1alpha1SourceResolver> localVarResponse = PatchSourceResolverWithHttpInfo(_namespace, name, body);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  patch the specified namespace scoped SourceResolver
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to patch.</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1SourceResolver</returns>
        public ApiResponse<KpackBuildV1alpha1SourceResolver> PatchSourceResolverWithHttpInfo (string _namespace, string name, Object body)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling KpackApi->PatchSourceResolver");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->PatchSourceResolver");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling KpackApi->PatchSourceResolver");

            var localVarPath = "/apis/kpack.io/v1alpha1/namespaces/{namespace}/sourceresolvers/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", this.Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchSourceResolver", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1SourceResolver>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1SourceResolver) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1SourceResolver)));
        }

        /// <summary>
        ///  patch the specified namespace scoped SourceResolver
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to patch.</param>
        /// <returns>Task of KpackBuildV1alpha1SourceResolver</returns>
        public async System.Threading.Tasks.Task<KpackBuildV1alpha1SourceResolver> PatchSourceResolverAsync (string _namespace, string name, Object body)
        {
             ApiResponse<KpackBuildV1alpha1SourceResolver> localVarResponse = await PatchSourceResolverAsyncWithHttpInfo(_namespace, name, body);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  patch the specified namespace scoped SourceResolver
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to patch.</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1SourceResolver)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1SourceResolver>> PatchSourceResolverAsyncWithHttpInfo (string _namespace, string name, Object body)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling KpackApi->PatchSourceResolver");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->PatchSourceResolver");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling KpackApi->PatchSourceResolver");

            var localVarPath = "/apis/kpack.io/v1alpha1/namespaces/{namespace}/sourceresolvers/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", this.Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchSourceResolver", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1SourceResolver>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1SourceResolver) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1SourceResolver)));
        }

        /// <summary>
        ///  partially update status of the specified namespace scoped SourceResolver
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>KpackBuildV1alpha1SourceResolver</returns>
        public KpackBuildV1alpha1SourceResolver PatchSourceResolverStatus (string _namespace, string name, Object body)
        {
             ApiResponse<KpackBuildV1alpha1SourceResolver> localVarResponse = PatchSourceResolverStatusWithHttpInfo(_namespace, name, body);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  partially update status of the specified namespace scoped SourceResolver
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>ApiResponse of KpackBuildV1alpha1SourceResolver</returns>
        public ApiResponse<KpackBuildV1alpha1SourceResolver> PatchSourceResolverStatusWithHttpInfo (string _namespace, string name, Object body)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling KpackApi->PatchSourceResolverStatus");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->PatchSourceResolverStatus");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling KpackApi->PatchSourceResolverStatus");

            var localVarPath = "/apis/kpack.io/v1alpha1/namespaces/{namespace}/sourceresolvers/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", this.Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchSourceResolverStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1SourceResolver>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1SourceResolver) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1SourceResolver)));
        }

        /// <summary>
        ///  partially update status of the specified namespace scoped SourceResolver
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>Task of KpackBuildV1alpha1SourceResolver</returns>
        public async System.Threading.Tasks.Task<KpackBuildV1alpha1SourceResolver> PatchSourceResolverStatusAsync (string _namespace, string name, Object body)
        {
             ApiResponse<KpackBuildV1alpha1SourceResolver> localVarResponse = await PatchSourceResolverStatusAsyncWithHttpInfo(_namespace, name, body);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  partially update status of the specified namespace scoped SourceResolver
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1SourceResolver)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1SourceResolver>> PatchSourceResolverStatusAsyncWithHttpInfo (string _namespace, string name, Object body)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling KpackApi->PatchSourceResolverStatus");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->PatchSourceResolverStatus");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling KpackApi->PatchSourceResolverStatus");

            var localVarPath = "/apis/kpack.io/v1alpha1/namespaces/{namespace}/sourceresolvers/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json-patch+json", 
                "application/merge-patch+json"
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", this.Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PATCH, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("PatchSourceResolverStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1SourceResolver>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1SourceResolver) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1SourceResolver)));
        }

        /// <summary>
        ///  replace the specified namespace scoped custom object
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to replace.</param>
        /// <returns>KpackBuildV1alpha1Build</returns>
        public KpackBuildV1alpha1Build ReplaceBuild (string _namespace, string name, KpackBuildV1alpha1Build body)
        {
             ApiResponse<KpackBuildV1alpha1Build> localVarResponse = ReplaceBuildWithHttpInfo(_namespace, name, body);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  replace the specified namespace scoped custom object
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to replace.</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1Build</returns>
        public ApiResponse<KpackBuildV1alpha1Build> ReplaceBuildWithHttpInfo (string _namespace, string name, KpackBuildV1alpha1Build body)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling KpackApi->ReplaceBuild");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->ReplaceBuild");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling KpackApi->ReplaceBuild");

            var localVarPath = "/apis/kpack.io/v1alpha1/namespaces/{namespace}/builds/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", this.Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceBuild", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1Build>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1Build) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1Build)));
        }

        /// <summary>
        ///  replace the specified namespace scoped custom object
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to replace.</param>
        /// <returns>Task of KpackBuildV1alpha1Build</returns>
        public async System.Threading.Tasks.Task<KpackBuildV1alpha1Build> ReplaceBuildAsync (string _namespace, string name, KpackBuildV1alpha1Build body)
        {
             ApiResponse<KpackBuildV1alpha1Build> localVarResponse = await ReplaceBuildAsyncWithHttpInfo(_namespace, name, body);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  replace the specified namespace scoped custom object
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to replace.</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1Build)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1Build>> ReplaceBuildAsyncWithHttpInfo (string _namespace, string name, KpackBuildV1alpha1Build body)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling KpackApi->ReplaceBuild");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->ReplaceBuild");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling KpackApi->ReplaceBuild");

            var localVarPath = "/apis/kpack.io/v1alpha1/namespaces/{namespace}/builds/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", this.Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceBuild", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1Build>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1Build) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1Build)));
        }

        /// <summary>
        ///  replace status of the specified namespace scoped Build
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>KpackBuildV1alpha1Build</returns>
        public KpackBuildV1alpha1Build ReplaceBuildStatus (string _namespace, string name, KpackBuildV1alpha1Build body)
        {
             ApiResponse<KpackBuildV1alpha1Build> localVarResponse = ReplaceBuildStatusWithHttpInfo(_namespace, name, body);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  replace status of the specified namespace scoped Build
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>ApiResponse of KpackBuildV1alpha1Build</returns>
        public ApiResponse<KpackBuildV1alpha1Build> ReplaceBuildStatusWithHttpInfo (string _namespace, string name, KpackBuildV1alpha1Build body)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling KpackApi->ReplaceBuildStatus");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->ReplaceBuildStatus");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling KpackApi->ReplaceBuildStatus");

            var localVarPath = "/apis/kpack.io/v1alpha1/namespaces/{namespace}/builds/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", this.Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceBuildStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1Build>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1Build) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1Build)));
        }

        /// <summary>
        ///  replace status of the specified namespace scoped Build
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>Task of KpackBuildV1alpha1Build</returns>
        public async System.Threading.Tasks.Task<KpackBuildV1alpha1Build> ReplaceBuildStatusAsync (string _namespace, string name, KpackBuildV1alpha1Build body)
        {
             ApiResponse<KpackBuildV1alpha1Build> localVarResponse = await ReplaceBuildStatusAsyncWithHttpInfo(_namespace, name, body);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  replace status of the specified namespace scoped Build
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1Build)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1Build>> ReplaceBuildStatusAsyncWithHttpInfo (string _namespace, string name, KpackBuildV1alpha1Build body)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling KpackApi->ReplaceBuildStatus");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->ReplaceBuildStatus");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling KpackApi->ReplaceBuildStatus");

            var localVarPath = "/apis/kpack.io/v1alpha1/namespaces/{namespace}/builds/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", this.Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceBuildStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1Build>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1Build) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1Build)));
        }

        /// <summary>
        ///  replace the specified namespace scoped custom object
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to replace.</param>
        /// <returns>KpackBuildV1alpha1Builder</returns>
        public KpackBuildV1alpha1Builder ReplaceBuilder (string _namespace, string name, KpackBuildV1alpha1Builder body)
        {
             ApiResponse<KpackBuildV1alpha1Builder> localVarResponse = ReplaceBuilderWithHttpInfo(_namespace, name, body);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  replace the specified namespace scoped custom object
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to replace.</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1Builder</returns>
        public ApiResponse<KpackBuildV1alpha1Builder> ReplaceBuilderWithHttpInfo (string _namespace, string name, KpackBuildV1alpha1Builder body)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling KpackApi->ReplaceBuilder");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->ReplaceBuilder");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling KpackApi->ReplaceBuilder");

            var localVarPath = "/apis/kpack.io/v1alpha1/namespaces/{namespace}/builders/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", this.Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceBuilder", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1Builder>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1Builder) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1Builder)));
        }

        /// <summary>
        ///  replace the specified namespace scoped custom object
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to replace.</param>
        /// <returns>Task of KpackBuildV1alpha1Builder</returns>
        public async System.Threading.Tasks.Task<KpackBuildV1alpha1Builder> ReplaceBuilderAsync (string _namespace, string name, KpackBuildV1alpha1Builder body)
        {
             ApiResponse<KpackBuildV1alpha1Builder> localVarResponse = await ReplaceBuilderAsyncWithHttpInfo(_namespace, name, body);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  replace the specified namespace scoped custom object
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to replace.</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1Builder)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1Builder>> ReplaceBuilderAsyncWithHttpInfo (string _namespace, string name, KpackBuildV1alpha1Builder body)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling KpackApi->ReplaceBuilder");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->ReplaceBuilder");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling KpackApi->ReplaceBuilder");

            var localVarPath = "/apis/kpack.io/v1alpha1/namespaces/{namespace}/builders/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", this.Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceBuilder", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1Builder>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1Builder) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1Builder)));
        }

        /// <summary>
        ///  replace status of the specified namespace scoped Builder
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>KpackBuildV1alpha1Builder</returns>
        public KpackBuildV1alpha1Builder ReplaceBuilderStatus (string _namespace, string name, KpackBuildV1alpha1Builder body)
        {
             ApiResponse<KpackBuildV1alpha1Builder> localVarResponse = ReplaceBuilderStatusWithHttpInfo(_namespace, name, body);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  replace status of the specified namespace scoped Builder
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>ApiResponse of KpackBuildV1alpha1Builder</returns>
        public ApiResponse<KpackBuildV1alpha1Builder> ReplaceBuilderStatusWithHttpInfo (string _namespace, string name, KpackBuildV1alpha1Builder body)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling KpackApi->ReplaceBuilderStatus");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->ReplaceBuilderStatus");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling KpackApi->ReplaceBuilderStatus");

            var localVarPath = "/apis/kpack.io/v1alpha1/namespaces/{namespace}/builders/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", this.Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceBuilderStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1Builder>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1Builder) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1Builder)));
        }

        /// <summary>
        ///  replace status of the specified namespace scoped Builder
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>Task of KpackBuildV1alpha1Builder</returns>
        public async System.Threading.Tasks.Task<KpackBuildV1alpha1Builder> ReplaceBuilderStatusAsync (string _namespace, string name, KpackBuildV1alpha1Builder body)
        {
             ApiResponse<KpackBuildV1alpha1Builder> localVarResponse = await ReplaceBuilderStatusAsyncWithHttpInfo(_namespace, name, body);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  replace status of the specified namespace scoped Builder
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1Builder)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1Builder>> ReplaceBuilderStatusAsyncWithHttpInfo (string _namespace, string name, KpackBuildV1alpha1Builder body)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling KpackApi->ReplaceBuilderStatus");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->ReplaceBuilderStatus");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling KpackApi->ReplaceBuilderStatus");

            var localVarPath = "/apis/kpack.io/v1alpha1/namespaces/{namespace}/builders/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", this.Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceBuilderStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1Builder>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1Builder) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1Builder)));
        }

        /// <summary>
        ///  replace the specified cluster scoped ClusterBuilder
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to replace.</param>
        /// <returns>KpackBuildV1alpha1ClusterBuilder</returns>
        public KpackBuildV1alpha1ClusterBuilder ReplaceClusterBuilder (string name, KpackBuildV1alpha1ClusterBuilder body)
        {
             ApiResponse<KpackBuildV1alpha1ClusterBuilder> localVarResponse = ReplaceClusterBuilderWithHttpInfo(name, body);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  replace the specified cluster scoped ClusterBuilder
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to replace.</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1ClusterBuilder</returns>
        public ApiResponse<KpackBuildV1alpha1ClusterBuilder> ReplaceClusterBuilderWithHttpInfo (string name, KpackBuildV1alpha1ClusterBuilder body)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->ReplaceClusterBuilder");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling KpackApi->ReplaceClusterBuilder");

            var localVarPath = "/apis/kpack.io/v1alpha1/clusterbuilders/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceClusterBuilder", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1ClusterBuilder>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1ClusterBuilder) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1ClusterBuilder)));
        }

        /// <summary>
        ///  replace the specified cluster scoped ClusterBuilder
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to replace.</param>
        /// <returns>Task of KpackBuildV1alpha1ClusterBuilder</returns>
        public async System.Threading.Tasks.Task<KpackBuildV1alpha1ClusterBuilder> ReplaceClusterBuilderAsync (string name, KpackBuildV1alpha1ClusterBuilder body)
        {
             ApiResponse<KpackBuildV1alpha1ClusterBuilder> localVarResponse = await ReplaceClusterBuilderAsyncWithHttpInfo(name, body);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  replace the specified cluster scoped ClusterBuilder
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to replace.</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1ClusterBuilder)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1ClusterBuilder>> ReplaceClusterBuilderAsyncWithHttpInfo (string name, KpackBuildV1alpha1ClusterBuilder body)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->ReplaceClusterBuilder");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling KpackApi->ReplaceClusterBuilder");

            var localVarPath = "/apis/kpack.io/v1alpha1/clusterbuilders/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceClusterBuilder", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1ClusterBuilder>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1ClusterBuilder) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1ClusterBuilder)));
        }

        /// <summary>
        ///  replace status of the specified cluster scoped ClusterBuilder
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>KpackBuildV1alpha1ClusterBuilder</returns>
        public KpackBuildV1alpha1ClusterBuilder ReplaceClusterBuilderStatus (string name, KpackBuildV1alpha1ClusterBuilder body)
        {
             ApiResponse<KpackBuildV1alpha1ClusterBuilder> localVarResponse = ReplaceClusterBuilderStatusWithHttpInfo(name, body);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  replace status of the specified cluster scoped ClusterBuilder
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>ApiResponse of KpackBuildV1alpha1ClusterBuilder</returns>
        public ApiResponse<KpackBuildV1alpha1ClusterBuilder> ReplaceClusterBuilderStatusWithHttpInfo (string name, KpackBuildV1alpha1ClusterBuilder body)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->ReplaceClusterBuilderStatus");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling KpackApi->ReplaceClusterBuilderStatus");

            var localVarPath = "/apis/kpack.io/v1alpha1/clusterbuilders/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceClusterBuilderStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1ClusterBuilder>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1ClusterBuilder) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1ClusterBuilder)));
        }

        /// <summary>
        ///  replace status of the specified cluster scoped ClusterBuilder
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>Task of KpackBuildV1alpha1ClusterBuilder</returns>
        public async System.Threading.Tasks.Task<KpackBuildV1alpha1ClusterBuilder> ReplaceClusterBuilderStatusAsync (string name, KpackBuildV1alpha1ClusterBuilder body)
        {
             ApiResponse<KpackBuildV1alpha1ClusterBuilder> localVarResponse = await ReplaceClusterBuilderStatusAsyncWithHttpInfo(name, body);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  replace status of the specified cluster scoped ClusterBuilder
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1ClusterBuilder)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1ClusterBuilder>> ReplaceClusterBuilderStatusAsyncWithHttpInfo (string name, KpackBuildV1alpha1ClusterBuilder body)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->ReplaceClusterBuilderStatus");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling KpackApi->ReplaceClusterBuilderStatus");

            var localVarPath = "/apis/kpack.io/v1alpha1/clusterbuilders/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceClusterBuilderStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1ClusterBuilder>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1ClusterBuilder) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1ClusterBuilder)));
        }

        /// <summary>
        ///  replace the specified cluster scoped ClusterStack
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to replace.</param>
        /// <returns>KpackBuildV1alpha1ClusterStack</returns>
        public KpackBuildV1alpha1ClusterStack ReplaceClusterStack (string name, KpackBuildV1alpha1ClusterStack body)
        {
             ApiResponse<KpackBuildV1alpha1ClusterStack> localVarResponse = ReplaceClusterStackWithHttpInfo(name, body);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  replace the specified cluster scoped ClusterStack
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to replace.</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1ClusterStack</returns>
        public ApiResponse<KpackBuildV1alpha1ClusterStack> ReplaceClusterStackWithHttpInfo (string name, KpackBuildV1alpha1ClusterStack body)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->ReplaceClusterStack");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling KpackApi->ReplaceClusterStack");

            var localVarPath = "/apis/kpack.io/v1alpha1/clusterstacks/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceClusterStack", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1ClusterStack>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1ClusterStack) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1ClusterStack)));
        }

        /// <summary>
        ///  replace the specified cluster scoped ClusterStack
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to replace.</param>
        /// <returns>Task of KpackBuildV1alpha1ClusterStack</returns>
        public async System.Threading.Tasks.Task<KpackBuildV1alpha1ClusterStack> ReplaceClusterStackAsync (string name, KpackBuildV1alpha1ClusterStack body)
        {
             ApiResponse<KpackBuildV1alpha1ClusterStack> localVarResponse = await ReplaceClusterStackAsyncWithHttpInfo(name, body);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  replace the specified cluster scoped ClusterStack
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to replace.</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1ClusterStack)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1ClusterStack>> ReplaceClusterStackAsyncWithHttpInfo (string name, KpackBuildV1alpha1ClusterStack body)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->ReplaceClusterStack");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling KpackApi->ReplaceClusterStack");

            var localVarPath = "/apis/kpack.io/v1alpha1/clusterstacks/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceClusterStack", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1ClusterStack>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1ClusterStack) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1ClusterStack)));
        }

        /// <summary>
        ///  replace status of the specified cluster scoped ClusterStack
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>KpackBuildV1alpha1ClusterStack</returns>
        public KpackBuildV1alpha1ClusterStack ReplaceClusterStackStatus (string name, KpackBuildV1alpha1ClusterStack body)
        {
             ApiResponse<KpackBuildV1alpha1ClusterStack> localVarResponse = ReplaceClusterStackStatusWithHttpInfo(name, body);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  replace status of the specified cluster scoped ClusterStack
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>ApiResponse of KpackBuildV1alpha1ClusterStack</returns>
        public ApiResponse<KpackBuildV1alpha1ClusterStack> ReplaceClusterStackStatusWithHttpInfo (string name, KpackBuildV1alpha1ClusterStack body)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->ReplaceClusterStackStatus");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling KpackApi->ReplaceClusterStackStatus");

            var localVarPath = "/apis/kpack.io/v1alpha1/clusterstacks/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceClusterStackStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1ClusterStack>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1ClusterStack) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1ClusterStack)));
        }

        /// <summary>
        ///  replace status of the specified cluster scoped ClusterStack
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>Task of KpackBuildV1alpha1ClusterStack</returns>
        public async System.Threading.Tasks.Task<KpackBuildV1alpha1ClusterStack> ReplaceClusterStackStatusAsync (string name, KpackBuildV1alpha1ClusterStack body)
        {
             ApiResponse<KpackBuildV1alpha1ClusterStack> localVarResponse = await ReplaceClusterStackStatusAsyncWithHttpInfo(name, body);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  replace status of the specified cluster scoped ClusterStack
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1ClusterStack)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1ClusterStack>> ReplaceClusterStackStatusAsyncWithHttpInfo (string name, KpackBuildV1alpha1ClusterStack body)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->ReplaceClusterStackStatus");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling KpackApi->ReplaceClusterStackStatus");

            var localVarPath = "/apis/kpack.io/v1alpha1/clusterstacks/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceClusterStackStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1ClusterStack>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1ClusterStack) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1ClusterStack)));
        }

        /// <summary>
        ///  replace the specified cluster scoped ClusterStore
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to replace.</param>
        /// <returns>KpackBuildV1alpha1ClusterStore</returns>
        public KpackBuildV1alpha1ClusterStore ReplaceClusterStore (string name, KpackBuildV1alpha1ClusterStore body)
        {
             ApiResponse<KpackBuildV1alpha1ClusterStore> localVarResponse = ReplaceClusterStoreWithHttpInfo(name, body);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  replace the specified cluster scoped ClusterStore
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to replace.</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1ClusterStore</returns>
        public ApiResponse<KpackBuildV1alpha1ClusterStore> ReplaceClusterStoreWithHttpInfo (string name, KpackBuildV1alpha1ClusterStore body)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->ReplaceClusterStore");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling KpackApi->ReplaceClusterStore");

            var localVarPath = "/apis/kpack.io/v1alpha1/clusterstores/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceClusterStore", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1ClusterStore>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1ClusterStore) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1ClusterStore)));
        }

        /// <summary>
        ///  replace the specified cluster scoped ClusterStore
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to replace.</param>
        /// <returns>Task of KpackBuildV1alpha1ClusterStore</returns>
        public async System.Threading.Tasks.Task<KpackBuildV1alpha1ClusterStore> ReplaceClusterStoreAsync (string name, KpackBuildV1alpha1ClusterStore body)
        {
             ApiResponse<KpackBuildV1alpha1ClusterStore> localVarResponse = await ReplaceClusterStoreAsyncWithHttpInfo(name, body);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  replace the specified cluster scoped ClusterStore
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to replace.</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1ClusterStore)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1ClusterStore>> ReplaceClusterStoreAsyncWithHttpInfo (string name, KpackBuildV1alpha1ClusterStore body)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->ReplaceClusterStore");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling KpackApi->ReplaceClusterStore");

            var localVarPath = "/apis/kpack.io/v1alpha1/clusterstores/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceClusterStore", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1ClusterStore>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1ClusterStore) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1ClusterStore)));
        }

        /// <summary>
        ///  replace status of the specified cluster scoped ClusterStore
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>KpackBuildV1alpha1ClusterStore</returns>
        public KpackBuildV1alpha1ClusterStore ReplaceClusterStoreStatus (string name, KpackBuildV1alpha1ClusterStore body)
        {
             ApiResponse<KpackBuildV1alpha1ClusterStore> localVarResponse = ReplaceClusterStoreStatusWithHttpInfo(name, body);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  replace status of the specified cluster scoped ClusterStore
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>ApiResponse of KpackBuildV1alpha1ClusterStore</returns>
        public ApiResponse<KpackBuildV1alpha1ClusterStore> ReplaceClusterStoreStatusWithHttpInfo (string name, KpackBuildV1alpha1ClusterStore body)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->ReplaceClusterStoreStatus");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling KpackApi->ReplaceClusterStoreStatus");

            var localVarPath = "/apis/kpack.io/v1alpha1/clusterstores/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceClusterStoreStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1ClusterStore>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1ClusterStore) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1ClusterStore)));
        }

        /// <summary>
        ///  replace status of the specified cluster scoped ClusterStore
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>Task of KpackBuildV1alpha1ClusterStore</returns>
        public async System.Threading.Tasks.Task<KpackBuildV1alpha1ClusterStore> ReplaceClusterStoreStatusAsync (string name, KpackBuildV1alpha1ClusterStore body)
        {
             ApiResponse<KpackBuildV1alpha1ClusterStore> localVarResponse = await ReplaceClusterStoreStatusAsyncWithHttpInfo(name, body);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  replace status of the specified cluster scoped ClusterStore
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1ClusterStore)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1ClusterStore>> ReplaceClusterStoreStatusAsyncWithHttpInfo (string name, KpackBuildV1alpha1ClusterStore body)
        {
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->ReplaceClusterStoreStatus");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling KpackApi->ReplaceClusterStoreStatus");

            var localVarPath = "/apis/kpack.io/v1alpha1/clusterstores/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceClusterStoreStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1ClusterStore>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1ClusterStore) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1ClusterStore)));
        }

        /// <summary>
        ///  replace the specified namespace scoped custom object
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to replace.</param>
        /// <returns>KpackBuildV1alpha1Image</returns>
        public KpackBuildV1alpha1Image ReplaceImage (string _namespace, string name, KpackBuildV1alpha1Image body)
        {
             ApiResponse<KpackBuildV1alpha1Image> localVarResponse = ReplaceImageWithHttpInfo(_namespace, name, body);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  replace the specified namespace scoped custom object
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to replace.</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1Image</returns>
        public ApiResponse<KpackBuildV1alpha1Image> ReplaceImageWithHttpInfo (string _namespace, string name, KpackBuildV1alpha1Image body)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling KpackApi->ReplaceImage");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->ReplaceImage");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling KpackApi->ReplaceImage");

            var localVarPath = "/apis/kpack.io/v1alpha1/namespaces/{namespace}/images/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", this.Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceImage", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1Image>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1Image) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1Image)));
        }

        /// <summary>
        ///  replace the specified namespace scoped custom object
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to replace.</param>
        /// <returns>Task of KpackBuildV1alpha1Image</returns>
        public async System.Threading.Tasks.Task<KpackBuildV1alpha1Image> ReplaceImageAsync (string _namespace, string name, KpackBuildV1alpha1Image body)
        {
             ApiResponse<KpackBuildV1alpha1Image> localVarResponse = await ReplaceImageAsyncWithHttpInfo(_namespace, name, body);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  replace the specified namespace scoped custom object
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to replace.</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1Image)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1Image>> ReplaceImageAsyncWithHttpInfo (string _namespace, string name, KpackBuildV1alpha1Image body)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling KpackApi->ReplaceImage");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->ReplaceImage");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling KpackApi->ReplaceImage");

            var localVarPath = "/apis/kpack.io/v1alpha1/namespaces/{namespace}/images/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", this.Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceImage", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1Image>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1Image) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1Image)));
        }

        /// <summary>
        ///  replace status of the specified namespace scoped Image
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>KpackBuildV1alpha1Image</returns>
        public KpackBuildV1alpha1Image ReplaceImageStatus (string _namespace, string name, KpackBuildV1alpha1Image body)
        {
             ApiResponse<KpackBuildV1alpha1Image> localVarResponse = ReplaceImageStatusWithHttpInfo(_namespace, name, body);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  replace status of the specified namespace scoped Image
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>ApiResponse of KpackBuildV1alpha1Image</returns>
        public ApiResponse<KpackBuildV1alpha1Image> ReplaceImageStatusWithHttpInfo (string _namespace, string name, KpackBuildV1alpha1Image body)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling KpackApi->ReplaceImageStatus");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->ReplaceImageStatus");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling KpackApi->ReplaceImageStatus");

            var localVarPath = "/apis/kpack.io/v1alpha1/namespaces/{namespace}/images/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", this.Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceImageStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1Image>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1Image) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1Image)));
        }

        /// <summary>
        ///  replace status of the specified namespace scoped Image
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>Task of KpackBuildV1alpha1Image</returns>
        public async System.Threading.Tasks.Task<KpackBuildV1alpha1Image> ReplaceImageStatusAsync (string _namespace, string name, KpackBuildV1alpha1Image body)
        {
             ApiResponse<KpackBuildV1alpha1Image> localVarResponse = await ReplaceImageStatusAsyncWithHttpInfo(_namespace, name, body);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  replace status of the specified namespace scoped Image
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1Image)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1Image>> ReplaceImageStatusAsyncWithHttpInfo (string _namespace, string name, KpackBuildV1alpha1Image body)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling KpackApi->ReplaceImageStatus");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->ReplaceImageStatus");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling KpackApi->ReplaceImageStatus");

            var localVarPath = "/apis/kpack.io/v1alpha1/namespaces/{namespace}/images/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", this.Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceImageStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1Image>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1Image) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1Image)));
        }

        /// <summary>
        ///  replace the specified namespace scoped custom object
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to replace.</param>
        /// <returns>KpackBuildV1alpha1SourceResolver</returns>
        public KpackBuildV1alpha1SourceResolver ReplaceSourceResolver (string _namespace, string name, KpackBuildV1alpha1SourceResolver body)
        {
             ApiResponse<KpackBuildV1alpha1SourceResolver> localVarResponse = ReplaceSourceResolverWithHttpInfo(_namespace, name, body);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  replace the specified namespace scoped custom object
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to replace.</param>
        /// <returns>ApiResponse of KpackBuildV1alpha1SourceResolver</returns>
        public ApiResponse<KpackBuildV1alpha1SourceResolver> ReplaceSourceResolverWithHttpInfo (string _namespace, string name, KpackBuildV1alpha1SourceResolver body)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling KpackApi->ReplaceSourceResolver");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->ReplaceSourceResolver");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling KpackApi->ReplaceSourceResolver");

            var localVarPath = "/apis/kpack.io/v1alpha1/namespaces/{namespace}/sourceresolvers/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", this.Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceSourceResolver", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1SourceResolver>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1SourceResolver) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1SourceResolver)));
        }

        /// <summary>
        ///  replace the specified namespace scoped custom object
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to replace.</param>
        /// <returns>Task of KpackBuildV1alpha1SourceResolver</returns>
        public async System.Threading.Tasks.Task<KpackBuildV1alpha1SourceResolver> ReplaceSourceResolverAsync (string _namespace, string name, KpackBuildV1alpha1SourceResolver body)
        {
             ApiResponse<KpackBuildV1alpha1SourceResolver> localVarResponse = await ReplaceSourceResolverAsyncWithHttpInfo(_namespace, name, body);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  replace the specified namespace scoped custom object
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body">The JSON schema of the Resource to replace.</param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1SourceResolver)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1SourceResolver>> ReplaceSourceResolverAsyncWithHttpInfo (string _namespace, string name, KpackBuildV1alpha1SourceResolver body)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling KpackApi->ReplaceSourceResolver");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->ReplaceSourceResolver");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling KpackApi->ReplaceSourceResolver");

            var localVarPath = "/apis/kpack.io/v1alpha1/namespaces/{namespace}/sourceresolvers/{name}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", this.Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceSourceResolver", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1SourceResolver>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1SourceResolver) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1SourceResolver)));
        }

        /// <summary>
        ///  replace status of the specified namespace scoped SourceResolver
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>KpackBuildV1alpha1SourceResolver</returns>
        public KpackBuildV1alpha1SourceResolver ReplaceSourceResolverStatus (string _namespace, string name, KpackBuildV1alpha1SourceResolver body)
        {
             ApiResponse<KpackBuildV1alpha1SourceResolver> localVarResponse = ReplaceSourceResolverStatusWithHttpInfo(_namespace, name, body);
             return localVarResponse.Data;
        }

        /// <summary>
        ///  replace status of the specified namespace scoped SourceResolver
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>ApiResponse of KpackBuildV1alpha1SourceResolver</returns>
        public ApiResponse<KpackBuildV1alpha1SourceResolver> ReplaceSourceResolverStatusWithHttpInfo (string _namespace, string name, KpackBuildV1alpha1SourceResolver body)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling KpackApi->ReplaceSourceResolverStatus");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->ReplaceSourceResolverStatus");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling KpackApi->ReplaceSourceResolverStatus");

            var localVarPath = "/apis/kpack.io/v1alpha1/namespaces/{namespace}/sourceresolvers/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", this.Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) this.Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceSourceResolverStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1SourceResolver>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1SourceResolver) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1SourceResolver)));
        }

        /// <summary>
        ///  replace status of the specified namespace scoped SourceResolver
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>Task of KpackBuildV1alpha1SourceResolver</returns>
        public async System.Threading.Tasks.Task<KpackBuildV1alpha1SourceResolver> ReplaceSourceResolverStatusAsync (string _namespace, string name, KpackBuildV1alpha1SourceResolver body)
        {
             ApiResponse<KpackBuildV1alpha1SourceResolver> localVarResponse = await ReplaceSourceResolverStatusAsyncWithHttpInfo(_namespace, name, body);
             return localVarResponse.Data;

        }

        /// <summary>
        ///  replace status of the specified namespace scoped SourceResolver
        /// </summary>
        /// <exception cref="Org.OpenAPITools.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="_namespace">The custom resource&#39;s namespace</param>
        /// <param name="name">the custom object&#39;s name</param>
        /// <param name="body"></param>
        /// <returns>Task of ApiResponse (KpackBuildV1alpha1SourceResolver)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<KpackBuildV1alpha1SourceResolver>> ReplaceSourceResolverStatusAsyncWithHttpInfo (string _namespace, string name, KpackBuildV1alpha1SourceResolver body)
        {
            // verify the required parameter '_namespace' is set
            if (_namespace == null)
                throw new ApiException(400, "Missing required parameter '_namespace' when calling KpackApi->ReplaceSourceResolverStatus");
            // verify the required parameter 'name' is set
            if (name == null)
                throw new ApiException(400, "Missing required parameter 'name' when calling KpackApi->ReplaceSourceResolverStatus");
            // verify the required parameter 'body' is set
            if (body == null)
                throw new ApiException(400, "Missing required parameter 'body' when calling KpackApi->ReplaceSourceResolverStatus");

            var localVarPath = "/apis/kpack.io/v1alpha1/namespaces/{namespace}/sourceresolvers/{name}/status";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new List<KeyValuePair<String, String>>();
            var localVarHeaderParams = new Dictionary<String, String>(this.Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
            };
            String localVarHttpContentType = this.Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json",
                "application/yaml",
                "application/vnd.kubernetes.protobuf"
            };
            String localVarHttpHeaderAccept = this.Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (_namespace != null) localVarPathParams.Add("namespace", this.Configuration.ApiClient.ParameterToString(_namespace)); // path parameter
            if (name != null) localVarPathParams.Add("name", this.Configuration.ApiClient.ParameterToString(name)); // path parameter
            if (body != null && body.GetType() != typeof(byte[]))
            {
                localVarPostBody = this.Configuration.ApiClient.Serialize(body); // http body (model) parameter
            }
            else
            {
                localVarPostBody = body; // byte array
            }


            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await this.Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ReplaceSourceResolverStatus", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<KpackBuildV1alpha1SourceResolver>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => string.Join(",", x.Value)),
                (KpackBuildV1alpha1SourceResolver) this.Configuration.ApiClient.Deserialize(localVarResponse, typeof(KpackBuildV1alpha1SourceResolver)));
        }

    }
}
